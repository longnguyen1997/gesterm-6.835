# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GRT')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GRT')
    _GRT = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GRT', [dirname(__file__)])
        except ImportError:
            import _GRT
            return _GRT
        try:
            _mod = imp.load_module('_GRT', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GRT = swig_import_helper()
    del swig_import_helper
else:
    import _GRT
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GRT.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _GRT.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _GRT.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _GRT.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _GRT.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _GRT.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _GRT.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _GRT.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _GRT.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _GRT.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _GRT.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _GRT.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _GRT.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GRT.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class IntVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _GRT.IntVector___len__(self)

    def __getslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "std::vector< int,std::allocator< int > > *":
        return _GRT.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.IntVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< int >::difference_type', j: 'std::vector< int >::difference_type') -> "void":
        return _GRT.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _GRT.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _GRT.IntVector_pop(self)

    def append(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _GRT.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _GRT.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _GRT.IntVector_size(self)

    def swap(self, v: 'IntVector') -> "void":
        return _GRT.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _GRT.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _GRT.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _GRT.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _GRT.IntVector_rend(self)

    def clear(self) -> "void":
        return _GRT.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _GRT.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _GRT.IntVector_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< int >::value_type const &') -> "void":
        return _GRT.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _GRT.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _GRT.IntVector_back(self)

    def assign(self, n: 'std::vector< int >::size_type', x: 'std::vector< int >::value_type const &') -> "void":
        return _GRT.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.IntVector_insert(self, *args)

    def reserve(self, n: 'std::vector< int >::size_type') -> "void":
        return _GRT.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _GRT.IntVector_capacity(self)
    __swig_destroy__ = _GRT.delete_IntVector
    __del__ = lambda self: None
IntVector_swigregister = _GRT.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _GRT.DoubleVector___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _GRT.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _GRT.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _GRT.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _GRT.DoubleVector_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _GRT.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _GRT.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _GRT.DoubleVector_size(self)

    def swap(self, v: 'DoubleVector') -> "void":
        return _GRT.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _GRT.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _GRT.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _GRT.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _GRT.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _GRT.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _GRT.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _GRT.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _GRT.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _GRT.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _GRT.DoubleVector_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _GRT.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.DoubleVector_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _GRT.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _GRT.DoubleVector_capacity(self)
    __swig_destroy__ = _GRT.delete_DoubleVector
    __del__ = lambda self: None
DoubleVector_swigregister = _GRT.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class FloatVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.FloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.FloatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _GRT.FloatVector___len__(self)

    def __getslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "std::vector< float,std::allocator< float > > *":
        return _GRT.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.FloatVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< float >::difference_type', j: 'std::vector< float >::difference_type') -> "void":
        return _GRT.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _GRT.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.FloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _GRT.FloatVector_pop(self)

    def append(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _GRT.FloatVector_append(self, x)

    def empty(self) -> "bool":
        return _GRT.FloatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _GRT.FloatVector_size(self)

    def swap(self, v: 'FloatVector') -> "void":
        return _GRT.FloatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _GRT.FloatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _GRT.FloatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _GRT.FloatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _GRT.FloatVector_rend(self)

    def clear(self) -> "void":
        return _GRT.FloatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _GRT.FloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.FloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _GRT.FloatVector_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_FloatVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< float >::value_type const &') -> "void":
        return _GRT.FloatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _GRT.FloatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _GRT.FloatVector_back(self)

    def assign(self, n: 'std::vector< float >::size_type', x: 'std::vector< float >::value_type const &') -> "void":
        return _GRT.FloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.FloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.FloatVector_insert(self, *args)

    def reserve(self, n: 'std::vector< float >::size_type') -> "void":
        return _GRT.FloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _GRT.FloatVector_capacity(self)
    __swig_destroy__ = _GRT.delete_FloatVector
    __del__ = lambda self: None
FloatVector_swigregister = _GRT.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

PI = _GRT.PI
TWO_PI = _GRT.TWO_PI
ONE_OVER_TWO_PI = _GRT.ONE_OVER_TWO_PI
SQRT_TWO_PI = _GRT.SQRT_TWO_PI

def grt_sqr(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_sqr(x)
grt_sqr = _GRT.grt_sqr

def grt_sqrt(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_sqrt(x)
grt_sqrt = _GRT.grt_sqrt

def grt_antilog(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_antilog(x)
grt_antilog = _GRT.grt_antilog

def grt_exp(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_exp(x)
grt_exp = _GRT.grt_exp

def grt_log(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_log(x)
grt_log = _GRT.grt_log

def grt_sigmoid(x: 'GRT::Float const &') -> "GRT::Float":
    return _GRT.grt_sigmoid(x)
grt_sigmoid = _GRT.grt_sigmoid
GRT_DEFAULT_NULL_CLASS_LABEL = _GRT.GRT_DEFAULT_NULL_CLASS_LABEL
GRT_SAFE_CHECKING = _GRT.GRT_SAFE_CHECKING
GRT_VERSION_MAJOR = _GRT.GRT_VERSION_MAJOR
GRT_VERSION_MINOR = _GRT.GRT_VERSION_MINOR
GRT_VERSION_PATCH = _GRT.GRT_VERSION_PATCH
GRT_VERSION = _GRT.GRT_VERSION
GRT_REVISION = _GRT.GRT_REVISION
class Util(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Util, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Util, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_Util()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Util
    __del__ = lambda self: None
    if _newclass:
        getCxx11Enabled = staticmethod(_GRT.Util_getCxx11Enabled)
    else:
        getCxx11Enabled = _GRT.Util_getCxx11Enabled
    if _newclass:
        sleep = staticmethod(_GRT.Util_sleep)
    else:
        sleep = _GRT.Util_sleep
    if _newclass:
        timeAsString = staticmethod(_GRT.Util_timeAsString)
    else:
        timeAsString = _GRT.Util_timeAsString
    if _newclass:
        intToString = staticmethod(_GRT.Util_intToString)
    else:
        intToString = _GRT.Util_intToString
    if _newclass:
        toString = staticmethod(_GRT.Util_toString)
    else:
        toString = _GRT.Util_toString
    if _newclass:
        stringToInt = staticmethod(_GRT.Util_stringToInt)
    else:
        stringToInt = _GRT.Util_stringToInt
    if _newclass:
        stringToDouble = staticmethod(_GRT.Util_stringToDouble)
    else:
        stringToDouble = _GRT.Util_stringToDouble
    if _newclass:
        stringToFloat = staticmethod(_GRT.Util_stringToFloat)
    else:
        stringToFloat = _GRT.Util_stringToFloat
    if _newclass:
        stringToBool = staticmethod(_GRT.Util_stringToBool)
    else:
        stringToBool = _GRT.Util_stringToBool
    if _newclass:
        stringEndsWith = staticmethod(_GRT.Util_stringEndsWith)
    else:
        stringEndsWith = _GRT.Util_stringEndsWith
    if _newclass:
        sum = staticmethod(_GRT.Util_sum)
    else:
        sum = _GRT.Util_sum
    if _newclass:
        dotProduct = staticmethod(_GRT.Util_dotProduct)
    else:
        dotProduct = _GRT.Util_dotProduct
    if _newclass:
        euclideanDistance = staticmethod(_GRT.Util_euclideanDistance)
    else:
        euclideanDistance = _GRT.Util_euclideanDistance
    if _newclass:
        squaredEuclideanDistance = staticmethod(_GRT.Util_squaredEuclideanDistance)
    else:
        squaredEuclideanDistance = _GRT.Util_squaredEuclideanDistance
    if _newclass:
        manhattanDistance = staticmethod(_GRT.Util_manhattanDistance)
    else:
        manhattanDistance = _GRT.Util_manhattanDistance
    if _newclass:
        cosineDistance = staticmethod(_GRT.Util_cosineDistance)
    else:
        cosineDistance = _GRT.Util_cosineDistance
    if _newclass:
        scale = staticmethod(_GRT.Util_scale)
    else:
        scale = _GRT.Util_scale
    if _newclass:
        normalize = staticmethod(_GRT.Util_normalize)
    else:
        normalize = _GRT.Util_normalize
    if _newclass:
        limit = staticmethod(_GRT.Util_limit)
    else:
        limit = _GRT.Util_limit
    if _newclass:
        getMinIndex = staticmethod(_GRT.Util_getMinIndex)
    else:
        getMinIndex = _GRT.Util_getMinIndex
    if _newclass:
        getMaxIndex = staticmethod(_GRT.Util_getMaxIndex)
    else:
        getMaxIndex = _GRT.Util_getMaxIndex
    if _newclass:
        getMin = staticmethod(_GRT.Util_getMin)
    else:
        getMin = _GRT.Util_getMin
    if _newclass:
        getMax = staticmethod(_GRT.Util_getMax)
    else:
        getMax = _GRT.Util_getMax
    if _newclass:
        getOS = staticmethod(_GRT.Util_getOS)
    else:
        getOS = _GRT.Util_getOS
    if _newclass:
        cartToPolar = staticmethod(_GRT.Util_cartToPolar)
    else:
        cartToPolar = _GRT.Util_cartToPolar
    if _newclass:
        polarToCart = staticmethod(_GRT.Util_polarToCart)
    else:
        polarToCart = _GRT.Util_polarToCart
    if _newclass:
        parseDirectory = staticmethod(_GRT.Util_parseDirectory)
    else:
        parseDirectory = _GRT.Util_parseDirectory
    OS_UNKNOWN = _GRT.Util_OS_UNKNOWN
    OS_OSX = _GRT.Util_OS_OSX
    OS_LINUX = _GRT.Util_OS_LINUX
    OS_WINDOWS = _GRT.Util_OS_WINDOWS
Util_swigregister = _GRT.Util_swigregister
Util_swigregister(Util)

def Util_getCxx11Enabled() -> "bool":
    return _GRT.Util_getCxx11Enabled()
Util_getCxx11Enabled = _GRT.Util_getCxx11Enabled

def Util_sleep(numMilliseconds: 'unsigned int const &') -> "bool":
    return _GRT.Util_sleep(numMilliseconds)
Util_sleep = _GRT.Util_sleep

def Util_timeAsString(includeDate: 'bool const'=True) -> "std::string":
    return _GRT.Util_timeAsString(includeDate)
Util_timeAsString = _GRT.Util_timeAsString

def Util_intToString(*args) -> "std::string":
    return _GRT.Util_intToString(*args)
Util_intToString = _GRT.Util_intToString

def Util_toString(*args) -> "std::string":
    return _GRT.Util_toString(*args)
Util_toString = _GRT.Util_toString

def Util_stringToInt(s: 'std::string const &') -> "int":
    return _GRT.Util_stringToInt(s)
Util_stringToInt = _GRT.Util_stringToInt

def Util_stringToDouble(s: 'std::string const &') -> "double":
    return _GRT.Util_stringToDouble(s)
Util_stringToDouble = _GRT.Util_stringToDouble

def Util_stringToFloat(s: 'std::string const &') -> "GRT::Float":
    return _GRT.Util_stringToFloat(s)
Util_stringToFloat = _GRT.Util_stringToFloat

def Util_stringToBool(s: 'std::string const &') -> "bool":
    return _GRT.Util_stringToBool(s)
Util_stringToBool = _GRT.Util_stringToBool

def Util_stringEndsWith(str: 'std::string const &', ending: 'std::string const &') -> "bool":
    return _GRT.Util_stringEndsWith(str, ending)
Util_stringEndsWith = _GRT.Util_stringEndsWith

def Util_sum(x: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_sum(x)
Util_sum = _GRT.Util_sum

def Util_dotProduct(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_dotProduct(a, b)
Util_dotProduct = _GRT.Util_dotProduct

def Util_euclideanDistance(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_euclideanDistance(a, b)
Util_euclideanDistance = _GRT.Util_euclideanDistance

def Util_squaredEuclideanDistance(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_squaredEuclideanDistance(a, b)
Util_squaredEuclideanDistance = _GRT.Util_squaredEuclideanDistance

def Util_manhattanDistance(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_manhattanDistance(a, b)
Util_manhattanDistance = _GRT.Util_manhattanDistance

def Util_cosineDistance(a: 'VectorFloat', b: 'VectorFloat') -> "GRT::Float":
    return _GRT.Util_cosineDistance(a, b)
Util_cosineDistance = _GRT.Util_cosineDistance

def Util_scale(*args) -> "GRT::VectorFloat":
    return _GRT.Util_scale(*args)
Util_scale = _GRT.Util_scale

def Util_normalize(x: 'VectorFloat') -> "GRT::VectorFloat":
    return _GRT.Util_normalize(x)
Util_normalize = _GRT.Util_normalize

def Util_limit(*args) -> "GRT::VectorFloat":
    return _GRT.Util_limit(*args)
Util_limit = _GRT.Util_limit

def Util_getMinIndex(x: 'VectorFloat') -> "unsigned int":
    return _GRT.Util_getMinIndex(x)
Util_getMinIndex = _GRT.Util_getMinIndex

def Util_getMaxIndex(x: 'VectorFloat') -> "unsigned int":
    return _GRT.Util_getMaxIndex(x)
Util_getMaxIndex = _GRT.Util_getMaxIndex

def Util_getMin(*args) -> "unsigned int":
    return _GRT.Util_getMin(*args)
Util_getMin = _GRT.Util_getMin

def Util_getMax(*args) -> "unsigned int":
    return _GRT.Util_getMax(*args)
Util_getMax = _GRT.Util_getMax

def Util_getOS() -> "unsigned int":
    return _GRT.Util_getOS()
Util_getOS = _GRT.Util_getOS

def Util_cartToPolar(x: 'GRT::Float const', y: 'GRT::Float const', r: 'GRT::Float &', theta: 'GRT::Float &') -> "void":
    return _GRT.Util_cartToPolar(x, y, r, theta)
Util_cartToPolar = _GRT.Util_cartToPolar

def Util_polarToCart(r: 'GRT::Float const', theta: 'GRT::Float const', x: 'GRT::Float &', y: 'GRT::Float &') -> "void":
    return _GRT.Util_polarToCart(r, theta, x, y)
Util_polarToCart = _GRT.Util_polarToCart

def Util_parseDirectory(directoryPath: 'std::string const', type: 'std::string const', filenames: 'std::vector< std::string,std::allocator< std::string > > &') -> "bool":
    return _GRT.Util_parseDirectory(directoryPath, type, filenames)
Util_parseDirectory = _GRT.Util_parseDirectory

class GRTBase(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GRTBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GRTBase, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_GRTBase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GRTBase
    __del__ = lambda self: None

    def copyGRTBaseVariables(self, GRTBase: 'GRTBase') -> "bool":
        return _GRT.GRTBase_copyGRTBaseVariables(self, GRTBase)

    def getClassType(self) -> "std::string":
        return _GRT.GRTBase_getClassType(self)

    def getId(self) -> "std::string":
        return _GRT.GRTBase_getId(self)

    def getLastWarningMessage(self) -> "std::string":
        return _GRT.GRTBase_getLastWarningMessage(self)

    def getLastErrorMessage(self) -> "std::string":
        return _GRT.GRTBase_getLastErrorMessage(self)

    def getLastInfoMessage(self) -> "std::string":
        return _GRT.GRTBase_getLastInfoMessage(self)

    def setInfoLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.GRTBase_setInfoLoggingEnabled(self, loggingEnabled)

    def setWarningLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.GRTBase_setWarningLoggingEnabled(self, loggingEnabled)

    def setErrorLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.GRTBase_setErrorLoggingEnabled(self, loggingEnabled)

    def setDebugLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.GRTBase_setDebugLoggingEnabled(self, loggingEnabled)
    if _newclass:
        getGRTVersion = staticmethod(_GRT.GRTBase_getGRTVersion)
    else:
        getGRTVersion = _GRT.GRTBase_getGRTVersion
    if _newclass:
        getGRTRevison = staticmethod(_GRT.GRTBase_getGRTRevison)
    else:
        getGRTRevison = _GRT.GRTBase_getGRTRevison

    def getGRTBasePointer(self, *args) -> "GRT::GRTBase const *":
        return _GRT.GRTBase_getGRTBasePointer(self, *args)

    def scale(self, x: 'GRT::Float const &', minSource: 'GRT::Float const &', maxSource: 'GRT::Float const &', minTarget: 'GRT::Float const &', maxTarget: 'GRT::Float const &', constrain: 'bool const'=False) -> "GRT::Float":
        return _GRT.GRTBase_scale(self, x, minSource, maxSource, minTarget, maxTarget, constrain)

    def SQR(self, x: 'GRT::Float const &') -> "GRT::Float":
        return _GRT.GRTBase_SQR(self, x)
GRTBase_swigregister = _GRT.GRTBase_swigregister
GRTBase_swigregister(GRTBase)

def GRTBase_getGRTVersion(returnRevision: 'bool'=True) -> "std::string":
    return _GRT.GRTBase_getGRTVersion(returnRevision)
GRTBase_getGRTVersion = _GRT.GRTBase_getGRTVersion

def GRTBase_getGRTRevison() -> "std::string":
    return _GRT.GRTBase_getGRTRevison()
GRTBase_getGRTRevison = _GRT.GRTBase_getGRTRevison

class UINTVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UINTVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UINTVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.UINTVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.UINTVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.UINTVector___bool__(self)

    def __len__(self) -> "std::vector< UINT >::size_type":
        return _GRT.UINTVector___len__(self)

    def __getslice__(self, i: 'std::vector< UINT >::difference_type', j: 'std::vector< UINT >::difference_type') -> "std::vector< UINT,std::allocator< UINT > > *":
        return _GRT.UINTVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.UINTVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< UINT >::difference_type', j: 'std::vector< UINT >::difference_type') -> "void":
        return _GRT.UINTVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.UINTVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< UINT >::value_type const &":
        return _GRT.UINTVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.UINTVector___setitem__(self, *args)

    def pop(self) -> "std::vector< UINT >::value_type":
        return _GRT.UINTVector_pop(self)

    def append(self, x: 'std::vector< UINT >::value_type const &') -> "void":
        return _GRT.UINTVector_append(self, x)

    def empty(self) -> "bool":
        return _GRT.UINTVector_empty(self)

    def size(self) -> "std::vector< UINT >::size_type":
        return _GRT.UINTVector_size(self)

    def swap(self, v: 'UINTVector') -> "void":
        return _GRT.UINTVector_swap(self, v)

    def begin(self) -> "std::vector< UINT >::iterator":
        return _GRT.UINTVector_begin(self)

    def end(self) -> "std::vector< UINT >::iterator":
        return _GRT.UINTVector_end(self)

    def rbegin(self) -> "std::vector< UINT >::reverse_iterator":
        return _GRT.UINTVector_rbegin(self)

    def rend(self) -> "std::vector< UINT >::reverse_iterator":
        return _GRT.UINTVector_rend(self)

    def clear(self) -> "void":
        return _GRT.UINTVector_clear(self)

    def get_allocator(self) -> "std::vector< UINT >::allocator_type":
        return _GRT.UINTVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.UINTVector_pop_back(self)

    def erase(self, *args) -> "std::vector< UINT >::iterator":
        return _GRT.UINTVector_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_UINTVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< UINT >::value_type const &') -> "void":
        return _GRT.UINTVector_push_back(self, x)

    def front(self) -> "std::vector< UINT >::value_type const &":
        return _GRT.UINTVector_front(self)

    def back(self) -> "std::vector< UINT >::value_type const &":
        return _GRT.UINTVector_back(self)

    def assign(self, n: 'std::vector< UINT >::size_type', x: 'std::vector< UINT >::value_type const &') -> "void":
        return _GRT.UINTVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.UINTVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.UINTVector_insert(self, *args)

    def reserve(self, n: 'std::vector< UINT >::size_type') -> "void":
        return _GRT.UINTVector_reserve(self, n)

    def capacity(self) -> "std::vector< UINT >::size_type":
        return _GRT.UINTVector_capacity(self)
    __swig_destroy__ = _GRT.delete_UINTVector
    __del__ = lambda self: None
UINTVector_swigregister = _GRT.UINTVector_swigregister
UINTVector_swigregister(UINTVector)

class VectorTUINT(UINTVector):
    __swig_setmethods__ = {}
    for _s in [UINTVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorTUINT, name, value)
    __swig_getmethods__ = {}
    for _s in [UINTVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorTUINT, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_VectorTUINT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_VectorTUINT
    __del__ = lambda self: None

    def resize(self, *args) -> "bool":
        return _GRT.VectorTUINT_resize(self, *args)

    def copy(self, rhs: 'VectorTUINT') -> "bool":
        return _GRT.VectorTUINT_copy(self, rhs)

    def fill(self, value: 'UINT const &') -> "bool":
        return _GRT.VectorTUINT_fill(self, value)

    def setAll(self, value: 'UINT const &') -> "bool":
        return _GRT.VectorTUINT_setAll(self, value)

    def getSize(self) -> "UINT":
        return _GRT.VectorTUINT_getSize(self)

    def getData(self, *args) -> "UINT const *":
        return _GRT.VectorTUINT_getData(self, *args)
VectorTUINT_swigregister = _GRT.VectorTUINT_swigregister
VectorTUINT_swigregister(VectorTUINT)

class VectorTFloat(DoubleVector):
    __swig_setmethods__ = {}
    for _s in [DoubleVector]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorTFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [DoubleVector]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorTFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_VectorTFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_VectorTFloat
    __del__ = lambda self: None

    def resize(self, *args) -> "bool":
        return _GRT.VectorTFloat_resize(self, *args)

    def copy(self, rhs: 'VectorTFloat') -> "bool":
        return _GRT.VectorTFloat_copy(self, rhs)

    def fill(self, value: 'double const &') -> "bool":
        return _GRT.VectorTFloat_fill(self, value)

    def setAll(self, value: 'double const &') -> "bool":
        return _GRT.VectorTFloat_setAll(self, value)

    def getSize(self) -> "UINT":
        return _GRT.VectorTFloat_getSize(self)

    def getData(self, *args) -> "double const *":
        return _GRT.VectorTFloat_getData(self, *args)
VectorTFloat_swigregister = _GRT.VectorTFloat_swigregister
VectorTFloat_swigregister(VectorTFloat)

class VectorTVectorFloat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorTVectorFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorTVectorFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_VectorTVectorFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_VectorTVectorFloat
    __del__ = lambda self: None

    def resize(self, *args) -> "bool":
        return _GRT.VectorTVectorFloat_resize(self, *args)

    def copy(self, rhs: 'VectorTVectorFloat') -> "bool":
        return _GRT.VectorTVectorFloat_copy(self, rhs)

    def fill(self, value: 'VectorFloat') -> "bool":
        return _GRT.VectorTVectorFloat_fill(self, value)

    def setAll(self, value: 'VectorFloat') -> "bool":
        return _GRT.VectorTVectorFloat_setAll(self, value)

    def getSize(self) -> "UINT":
        return _GRT.VectorTVectorFloat_getSize(self)

    def getData(self, *args) -> "GRT::VectorFloat const *":
        return _GRT.VectorTVectorFloat_getData(self, *args)
VectorTVectorFloat_swigregister = _GRT.VectorTVectorFloat_swigregister
VectorTVectorFloat_swigregister(VectorTVectorFloat)

class VectorFloat(VectorTFloat):
    __swig_setmethods__ = {}
    for _s in [VectorTFloat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [VectorTFloat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VectorFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_VectorFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_VectorFloat
    __del__ = lambda self: None

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.VectorFloat_save(self, filename)

    def load(self, *args) -> "bool":
        return _GRT.VectorFloat_load(self, *args)

    def _print(self, *args) -> "bool":
        return _GRT.VectorFloat__print(self, *args)

    def scale(self, *args) -> "bool":
        return _GRT.VectorFloat_scale(self, *args)

    def getMinValue(self) -> "GRT::Float":
        return _GRT.VectorFloat_getMinValue(self)

    def getMaxValue(self) -> "GRT::Float":
        return _GRT.VectorFloat_getMaxValue(self)

    def getMean(self) -> "GRT::Float":
        return _GRT.VectorFloat_getMean(self)

    def getStdDev(self) -> "GRT::Float":
        return _GRT.VectorFloat_getStdDev(self)

    def getMinMax(self) -> "MinMax":
        return _GRT.VectorFloat_getMinMax(self)
VectorFloat_swigregister = _GRT.VectorFloat_swigregister
VectorFloat_swigregister(VectorFloat)

class MatrixTFloat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixTFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixTFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MatrixTFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MatrixTFloat
    __del__ = lambda self: None

    def getRowVector(self, r: 'unsigned int const') -> "GRT::Vector< double >":
        return _GRT.MatrixTFloat_getRowVector(self, r)

    def getColVector(self, c: 'unsigned int const') -> "GRT::Vector< double >":
        return _GRT.MatrixTFloat_getColVector(self, c)

    def getConcatenatedVector(self, concatByRow: 'bool const'=True) -> "GRT::Vector< double >":
        return _GRT.MatrixTFloat_getConcatenatedVector(self, concatByRow)

    def resize(self, *args) -> "bool":
        return _GRT.MatrixTFloat_resize(self, *args)

    def copy(self, rhs: 'MatrixTFloat') -> "bool":
        return _GRT.MatrixTFloat_copy(self, rhs)

    def setAllValues(self, value: 'double const &') -> "bool":
        return _GRT.MatrixTFloat_setAllValues(self, value)

    def setAll(self, value: 'double const &') -> "bool":
        return _GRT.MatrixTFloat_setAll(self, value)

    def setRowVector(self, row: 'VectorTFloat', rowIndex: 'unsigned int const') -> "bool":
        return _GRT.MatrixTFloat_setRowVector(self, row, rowIndex)

    def setColVector(self, column: 'VectorTFloat', colIndex: 'unsigned int const') -> "bool":
        return _GRT.MatrixTFloat_setColVector(self, column, colIndex)

    def push_back(self, sample: 'VectorTFloat') -> "bool":
        return _GRT.MatrixTFloat_push_back(self, sample)

    def reserve(self, capacity: 'unsigned int const') -> "bool":
        return _GRT.MatrixTFloat_reserve(self, capacity)

    def clear(self) -> "bool":
        return _GRT.MatrixTFloat_clear(self)

    def getNumRows(self) -> "unsigned int":
        return _GRT.MatrixTFloat_getNumRows(self)

    def getNumCols(self) -> "unsigned int":
        return _GRT.MatrixTFloat_getNumCols(self)

    def getCapacity(self) -> "unsigned int":
        return _GRT.MatrixTFloat_getCapacity(self)

    def getSize(self) -> "unsigned int":
        return _GRT.MatrixTFloat_getSize(self)

    def getDataPointer(self) -> "double **":
        return _GRT.MatrixTFloat_getDataPointer(self)

    def getData(self) -> "double *":
        return _GRT.MatrixTFloat_getData(self)
MatrixTFloat_swigregister = _GRT.MatrixTFloat_swigregister
MatrixTFloat_swigregister(MatrixTFloat)

class MatrixFloat(MatrixTFloat):
    __swig_setmethods__ = {}
    for _s in [MatrixTFloat]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixFloat, name, value)
    __swig_getmethods__ = {}
    for _s in [MatrixTFloat]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MatrixFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MatrixFloat
    __del__ = lambda self: None

    def getRow(self, r: 'unsigned int const') -> "GRT::VectorFloat":
        return _GRT.MatrixFloat_getRow(self, r)

    def getCol(self, c: 'unsigned int const') -> "GRT::VectorFloat":
        return _GRT.MatrixFloat_getCol(self, c)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.MatrixFloat_save(self, filename)

    def load(self, *args) -> "bool":
        return _GRT.MatrixFloat_load(self, *args)

    def saveToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.MatrixFloat_saveToCSVFile(self, filename)

    def loadFromCSVFile(self, *args) -> "bool":
        return _GRT.MatrixFloat_loadFromCSVFile(self, *args)

    def _print(self, *args) -> "bool":
        return _GRT.MatrixFloat__print(self, *args)

    def transpose(self) -> "bool":
        return _GRT.MatrixFloat_transpose(self)

    def scale(self, *args) -> "bool":
        return _GRT.MatrixFloat_scale(self, *args)

    def znorm(self, alpha: 'GRT::Float const'=0.001) -> "bool":
        return _GRT.MatrixFloat_znorm(self, alpha)

    def multiple(self, *args) -> "bool":
        return _GRT.MatrixFloat_multiple(self, *args)

    def add(self, *args) -> "bool":
        return _GRT.MatrixFloat_add(self, *args)

    def subtract(self, *args) -> "bool":
        return _GRT.MatrixFloat_subtract(self, *args)

    def getMinValue(self) -> "GRT::Float":
        return _GRT.MatrixFloat_getMinValue(self)

    def getMaxValue(self) -> "GRT::Float":
        return _GRT.MatrixFloat_getMaxValue(self)

    def getMean(self) -> "GRT::VectorFloat":
        return _GRT.MatrixFloat_getMean(self)

    def getStdDev(self) -> "GRT::VectorFloat":
        return _GRT.MatrixFloat_getStdDev(self)

    def getCovarianceMatrix(self) -> "GRT::MatrixFloat":
        return _GRT.MatrixFloat_getCovarianceMatrix(self)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.MatrixFloat_getRanges(self)

    def getTrace(self) -> "GRT::Float":
        return _GRT.MatrixFloat_getTrace(self)
MatrixFloat_swigregister = _GRT.MatrixFloat_swigregister
MatrixFloat_swigregister(MatrixFloat)

class ClassificationData(GRTBase):
    __swig_setmethods__ = {}
    for _s in [GRTBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassificationData, name, value)
    __swig_getmethods__ = {}
    for _s in [GRTBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClassificationData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClassificationData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClassificationData
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _GRT.ClassificationData_clear(self)

    def setNumDimensions(self, numDimensions: 'UINT') -> "bool":
        return _GRT.ClassificationData_setNumDimensions(self, numDimensions)

    def setDatasetName(self, datasetName: 'std::string') -> "bool":
        return _GRT.ClassificationData_setDatasetName(self, datasetName)

    def setInfoText(self, infoText: 'std::string') -> "bool":
        return _GRT.ClassificationData_setInfoText(self, infoText)

    def setClassNameForCorrespondingClassLabel(self, className: 'std::string const', classLabel: 'UINT const') -> "bool":
        return _GRT.ClassificationData_setClassNameForCorrespondingClassLabel(self, className, classLabel)

    def setAllowNullGestureClass(self, allowNullGestureClass: 'bool const') -> "bool":
        return _GRT.ClassificationData_setAllowNullGestureClass(self, allowNullGestureClass)

    def addSample(self, classLabel: 'UINT const', sample: 'VectorFloat') -> "bool":
        return _GRT.ClassificationData_addSample(self, classLabel, sample)

    def removeSample(self, index: 'UINT const') -> "bool":
        return _GRT.ClassificationData_removeSample(self, index)

    def removeLastSample(self) -> "bool":
        return _GRT.ClassificationData_removeLastSample(self)

    def reserve(self, M: 'UINT const') -> "bool":
        return _GRT.ClassificationData_reserve(self, M)

    def addClass(self, *args) -> "bool":
        return _GRT.ClassificationData_addClass(self, *args)

    def removeClass(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.ClassificationData_removeClass(self, classLabel)

    def eraseAllSamplesWithClassLabel(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.ClassificationData_eraseAllSamplesWithClassLabel(self, classLabel)

    def relabelAllSamplesWithClassLabel(self, oldClassLabel: 'UINT const', newClassLabel: 'UINT const') -> "bool":
        return _GRT.ClassificationData_relabelAllSamplesWithClassLabel(self, oldClassLabel, newClassLabel)

    def setExternalRanges(self, externalRanges: 'GRT::Vector< MinMax > const &', useExternalRanges: 'bool const'=False) -> "bool":
        return _GRT.ClassificationData_setExternalRanges(self, externalRanges, useExternalRanges)

    def enableExternalRangeScaling(self, useExternalRanges: 'bool const') -> "bool":
        return _GRT.ClassificationData_enableExternalRangeScaling(self, useExternalRanges)

    def scale(self, *args) -> "bool":
        return _GRT.ClassificationData_scale(self, *args)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_save(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_load(self, filename)

    def saveDatasetToFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_saveDatasetToFile(self, filename)

    def loadDatasetFromFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_loadDatasetFromFile(self, filename)

    def saveDatasetToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationData_saveDatasetToCSVFile(self, filename)

    def loadDatasetFromCSVFile(self, filename: 'std::string const &', classLabelColumnIndex: 'UINT const'=0) -> "bool":
        return _GRT.ClassificationData_loadDatasetFromCSVFile(self, filename, classLabelColumnIndex)

    def printStats(self) -> "bool":
        return _GRT.ClassificationData_printStats(self)

    def sortClassLabels(self) -> "bool":
        return _GRT.ClassificationData_sortClassLabels(self)

    def merge(self, data: 'ClassificationData') -> "bool":
        return _GRT.ClassificationData_merge(self, data)

    def partition(self, partitionPercentage: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "GRT::ClassificationData":
        return _GRT.ClassificationData_partition(self, partitionPercentage, useStratifiedSampling)

    def split(self, splitPercentage: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "GRT::ClassificationData":
        return _GRT.ClassificationData_split(self, splitPercentage, useStratifiedSampling)

    def spiltDataIntoKFolds(self, K: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "bool":
        return _GRT.ClassificationData_spiltDataIntoKFolds(self, K, useStratifiedSampling)

    def getTrainingFoldData(self, foldIndex: 'UINT const') -> "GRT::ClassificationData":
        return _GRT.ClassificationData_getTrainingFoldData(self, foldIndex)

    def getTestFoldData(self, foldIndex: 'UINT const') -> "GRT::ClassificationData":
        return _GRT.ClassificationData_getTestFoldData(self, foldIndex)

    def getClassData(self, classLabel: 'UINT const') -> "GRT::ClassificationData":
        return _GRT.ClassificationData_getClassData(self, classLabel)

    def getBootstrappedDataset(self, numSamples: 'UINT const'=0, balanceDataset: 'bool const'=False) -> "GRT::ClassificationData":
        return _GRT.ClassificationData_getBootstrappedDataset(self, numSamples, balanceDataset)

    def reformatAsRegressionData(self) -> "GRT::RegressionData":
        return _GRT.ClassificationData_reformatAsRegressionData(self)

    def reformatAsUnlabelledData(self) -> "GRT::UnlabelledData":
        return _GRT.ClassificationData_reformatAsUnlabelledData(self)

    def getDatasetName(self) -> "std::string":
        return _GRT.ClassificationData_getDatasetName(self)

    def getInfoText(self) -> "std::string":
        return _GRT.ClassificationData_getInfoText(self)

    def getStatsAsString(self) -> "std::string":
        return _GRT.ClassificationData_getStatsAsString(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.ClassificationData_getNumDimensions(self)

    def getNumSamples(self) -> "UINT":
        return _GRT.ClassificationData_getNumSamples(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.ClassificationData_getNumClasses(self)

    def getMinimumClassLabel(self) -> "UINT":
        return _GRT.ClassificationData_getMinimumClassLabel(self)

    def getMaximumClassLabel(self) -> "UINT":
        return _GRT.ClassificationData_getMaximumClassLabel(self)

    def getClassLabelIndexValue(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.ClassificationData_getClassLabelIndexValue(self, classLabel)

    def getClassNameForCorrespondingClassLabel(self, classLabel: 'UINT const') -> "std::string":
        return _GRT.ClassificationData_getClassNameForCorrespondingClassLabel(self, classLabel)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.ClassificationData_getRanges(self)

    def getClassLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.ClassificationData_getClassLabels(self)

    def getNumSamplesPerClass(self) -> "GRT::Vector< UINT >":
        return _GRT.ClassificationData_getNumSamplesPerClass(self)

    def getClassTracker(self) -> "GRT::Vector< ClassTracker >":
        return _GRT.ClassificationData_getClassTracker(self)

    def getClassHistogramData(self, classLabel: 'UINT const', numBins: 'UINT const') -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getClassHistogramData(self, classLabel, numBins)

    def getHistogramData(self, numBins: 'UINT const') -> "GRT::Vector< GRT::MatrixFloat >":
        return _GRT.ClassificationData_getHistogramData(self, numBins)

    def getClassificationData(self) -> "GRT::Vector< ClassificationSample >":
        return _GRT.ClassificationData_getClassificationData(self)

    def getClassProbabilities(self, *args) -> "GRT::VectorFloat":
        return _GRT.ClassificationData_getClassProbabilities(self, *args)

    def getMean(self) -> "GRT::VectorFloat":
        return _GRT.ClassificationData_getMean(self)

    def getStdDev(self) -> "GRT::VectorFloat":
        return _GRT.ClassificationData_getStdDev(self)

    def getClassMean(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getClassMean(self)

    def getClassStdDev(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getClassStdDev(self)

    def getCovarianceMatrix(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getCovarianceMatrix(self)

    def getClassDataIndexes(self, classLabel: 'UINT const') -> "GRT::Vector< UINT >":
        return _GRT.ClassificationData_getClassDataIndexes(self, classLabel)

    def getDataAsMatrixDouble(self) -> "GRT::MatrixDouble":
        return _GRT.ClassificationData_getDataAsMatrixDouble(self)

    def getDataAsMatrixFloat(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationData_getDataAsMatrixFloat(self)
    if _newclass:
        generateGaussDataset = staticmethod(_GRT.ClassificationData_generateGaussDataset)
    else:
        generateGaussDataset = _GRT.ClassificationData_generateGaussDataset
    if _newclass:
        generateGaussLinearDataset = staticmethod(_GRT.ClassificationData_generateGaussLinearDataset)
    else:
        generateGaussLinearDataset = _GRT.ClassificationData_generateGaussLinearDataset

    def get(self, i: 'int const &') -> "GRT::ClassificationSample &":
        return _GRT.ClassificationData_get(self, i)
ClassificationData_swigregister = _GRT.ClassificationData_swigregister
ClassificationData_swigregister(ClassificationData)

def ClassificationData_generateGaussDataset(*args) -> "GRT::ClassificationData":
    return _GRT.ClassificationData_generateGaussDataset(*args)
ClassificationData_generateGaussDataset = _GRT.ClassificationData_generateGaussDataset

def ClassificationData_generateGaussLinearDataset(numSamples: 'UINT const'=10000, numClasses: 'UINT const'=10, numDimensions: 'UINT const'=3, range: 'GRT::Float const'=10, sigma: 'GRT::Float const'=1) -> "GRT::ClassificationData":
    return _GRT.ClassificationData_generateGaussLinearDataset(numSamples, numClasses, numDimensions, range, sigma)
ClassificationData_generateGaussLinearDataset = _GRT.ClassificationData_generateGaussLinearDataset

class ClassificationSample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassificationSample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClassificationSample, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClassificationSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClassificationSample
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.ClassificationSample_clear(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.ClassificationSample_getNumDimensions(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.ClassificationSample_getClassLabel(self)

    def getSample(self, *args) -> "GRT::VectorFloat &":
        return _GRT.ClassificationSample_getSample(self, *args)

    def set(self, classLabel: 'UINT', sample: 'VectorFloat') -> "bool":
        return _GRT.ClassificationSample_set(self, classLabel, sample)

    def setClassLabel(self, classLabel: 'UINT const') -> "bool":
        return _GRT.ClassificationSample_setClassLabel(self, classLabel)

    def setSample(self, sample: 'VectorFloat') -> "bool":
        return _GRT.ClassificationSample_setSample(self, sample)
ClassificationSample_swigregister = _GRT.ClassificationSample_swigregister
ClassificationSample_swigregister(ClassificationSample)

class TimeSeriesClassificationData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeriesClassificationData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeriesClassificationData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_TimeSeriesClassificationData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TimeSeriesClassificationData
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _GRT.TimeSeriesClassificationData_clear(self)

    def setNumDimensions(self, numDimensions: 'UINT const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setNumDimensions(self, numDimensions)

    def setDatasetName(self, datasetName: 'std::string const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setDatasetName(self, datasetName)

    def setInfoText(self, infoText: 'std::string const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setInfoText(self, infoText)

    def setClassNameForCorrespondingClassLabel(self, className: 'std::string const', classLabel: 'UINT const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setClassNameForCorrespondingClassLabel(self, className, classLabel)

    def setAllowNullGestureClass(self, allowNullGestureClass: 'bool const') -> "bool":
        return _GRT.TimeSeriesClassificationData_setAllowNullGestureClass(self, allowNullGestureClass)

    def addSample(self, classLabel: 'UINT const', trainingSample: 'MatrixFloat') -> "bool":
        return _GRT.TimeSeriesClassificationData_addSample(self, classLabel, trainingSample)

    def removeLastSample(self) -> "bool":
        return _GRT.TimeSeriesClassificationData_removeLastSample(self)

    def eraseAllSamplesWithClassLabel(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.TimeSeriesClassificationData_eraseAllSamplesWithClassLabel(self, classLabel)

    def relabelAllSamplesWithClassLabel(self, oldClassLabel: 'UINT const', newClassLabel: 'UINT const') -> "bool":
        return _GRT.TimeSeriesClassificationData_relabelAllSamplesWithClassLabel(self, oldClassLabel, newClassLabel)

    def setExternalRanges(self, externalRanges: 'GRT::Vector< MinMax > const &', useExternalRanges: 'bool const'=False) -> "bool":
        return _GRT.TimeSeriesClassificationData_setExternalRanges(self, externalRanges, useExternalRanges)

    def enableExternalRangeScaling(self, useExternalRanges: 'bool const') -> "bool":
        return _GRT.TimeSeriesClassificationData_enableExternalRangeScaling(self, useExternalRanges)

    def scale(self, *args) -> "bool":
        return _GRT.TimeSeriesClassificationData_scale(self, *args)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.TimeSeriesClassificationData_save(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.TimeSeriesClassificationData_load(self, filename)

    def saveDatasetToFile(self, filename: 'std::string const') -> "bool":
        return _GRT.TimeSeriesClassificationData_saveDatasetToFile(self, filename)

    def loadDatasetFromFile(self, filename: 'std::string const') -> "bool":
        return _GRT.TimeSeriesClassificationData_loadDatasetFromFile(self, filename)

    def saveDatasetToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.TimeSeriesClassificationData_saveDatasetToCSVFile(self, filename)

    def loadDatasetFromCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.TimeSeriesClassificationData_loadDatasetFromCSVFile(self, filename)

    def printStats(self) -> "bool":
        return _GRT.TimeSeriesClassificationData_printStats(self)

    def getStatsAsString(self) -> "std::string":
        return _GRT.TimeSeriesClassificationData_getStatsAsString(self)

    def partition(self, partitionPercentage: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_partition(self, partitionPercentage, useStratifiedSampling)

    def split(self, partitionPercentage: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_split(self, partitionPercentage, useStratifiedSampling)

    def merge(self, labelledData: 'TimeSeriesClassificationData') -> "bool":
        return _GRT.TimeSeriesClassificationData_merge(self, labelledData)

    def spiltDataIntoKFolds(self, K: 'UINT const', useStratifiedSampling: 'bool const'=False) -> "bool":
        return _GRT.TimeSeriesClassificationData_spiltDataIntoKFolds(self, K, useStratifiedSampling)

    def getTrainingFoldData(self, foldIndex: 'UINT const') -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_getTrainingFoldData(self, foldIndex)

    def getTestFoldData(self, foldIndex: 'UINT const') -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_getTestFoldData(self, foldIndex)

    def getClassData(self, classLabel: 'UINT const') -> "GRT::TimeSeriesClassificationData":
        return _GRT.TimeSeriesClassificationData_getClassData(self, classLabel)

    def reformatAsUnlabelledData(self) -> "GRT::UnlabelledData":
        return _GRT.TimeSeriesClassificationData_reformatAsUnlabelledData(self)

    def getDatasetName(self) -> "std::string":
        return _GRT.TimeSeriesClassificationData_getDatasetName(self)

    def getInfoText(self) -> "std::string":
        return _GRT.TimeSeriesClassificationData_getInfoText(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getNumDimensions(self)

    def getNumSamples(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getNumSamples(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getNumClasses(self)

    def getMinimumClassLabel(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getMinimumClassLabel(self)

    def getMaximumClassLabel(self) -> "UINT":
        return _GRT.TimeSeriesClassificationData_getMaximumClassLabel(self)

    def getClassLabelIndexValue(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.TimeSeriesClassificationData_getClassLabelIndexValue(self, classLabel)

    def getClassNameForCorrespondingClassLabel(self, classLabel: 'UINT const') -> "std::string":
        return _GRT.TimeSeriesClassificationData_getClassNameForCorrespondingClassLabel(self, classLabel)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.TimeSeriesClassificationData_getRanges(self)

    def getClassTracker(self) -> "GRT::Vector< ClassTracker >":
        return _GRT.TimeSeriesClassificationData_getClassTracker(self)

    def getClassificationData(self) -> "GRT::Vector< TimeSeriesClassificationSample >":
        return _GRT.TimeSeriesClassificationData_getClassificationData(self)

    def getDataAsMatrixFloat(self) -> "GRT::MatrixFloat":
        return _GRT.TimeSeriesClassificationData_getDataAsMatrixFloat(self)

    def get(self, i: 'int const &') -> "GRT::TimeSeriesClassificationSample &":
        return _GRT.TimeSeriesClassificationData_get(self, i)
TimeSeriesClassificationData_swigregister = _GRT.TimeSeriesClassificationData_swigregister
TimeSeriesClassificationData_swigregister(TimeSeriesClassificationData)

class TimeSeriesClassificationSample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeSeriesClassificationSample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TimeSeriesClassificationSample, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_TimeSeriesClassificationSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TimeSeriesClassificationSample
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.TimeSeriesClassificationSample_clear(self)

    def addSample(self, classLabel: 'UINT const', sample: 'VectorFloat') -> "bool":
        return _GRT.TimeSeriesClassificationSample_addSample(self, classLabel, sample)

    def setTrainingSample(self, classLabel: 'UINT const', data: 'MatrixFloat') -> "bool":
        return _GRT.TimeSeriesClassificationSample_setTrainingSample(self, classLabel, data)

    def getLength(self) -> "UINT":
        return _GRT.TimeSeriesClassificationSample_getLength(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.TimeSeriesClassificationSample_getNumDimensions(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.TimeSeriesClassificationSample_getClassLabel(self)

    def getData(self, *args) -> "GRT::MatrixFloat const &":
        return _GRT.TimeSeriesClassificationSample_getData(self, *args)
TimeSeriesClassificationSample_swigregister = _GRT.TimeSeriesClassificationSample_swigregister
TimeSeriesClassificationSample_swigregister(TimeSeriesClassificationSample)

class ClassificationDataStream(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassificationDataStream, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClassificationDataStream, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClassificationDataStream(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClassificationDataStream
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _GRT.ClassificationDataStream_clear(self)

    def setNumDimensions(self, numDimensions: 'UINT const') -> "bool":
        return _GRT.ClassificationDataStream_setNumDimensions(self, numDimensions)

    def setDatasetName(self, datasetName: 'std::string const') -> "bool":
        return _GRT.ClassificationDataStream_setDatasetName(self, datasetName)

    def setInfoText(self, infoText: 'std::string const') -> "bool":
        return _GRT.ClassificationDataStream_setInfoText(self, infoText)

    def setClassNameForCorrespondingClassLabel(self, className: 'std::string const', classLabel: 'UINT const') -> "bool":
        return _GRT.ClassificationDataStream_setClassNameForCorrespondingClassLabel(self, className, classLabel)

    def addSample(self, *args) -> "bool":
        return _GRT.ClassificationDataStream_addSample(self, *args)

    def removeLastSample(self) -> "bool":
        return _GRT.ClassificationDataStream_removeLastSample(self)

    def eraseAllSamplesWithClassLabel(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.ClassificationDataStream_eraseAllSamplesWithClassLabel(self, classLabel)

    def relabelAllSamplesWithClassLabel(self, oldClassLabel: 'UINT const', newClassLabel: 'UINT const') -> "bool":
        return _GRT.ClassificationDataStream_relabelAllSamplesWithClassLabel(self, oldClassLabel, newClassLabel)

    def setExternalRanges(self, externalRanges: 'GRT::Vector< MinMax > const &', useExternalRanges: 'bool const'=False) -> "bool":
        return _GRT.ClassificationDataStream_setExternalRanges(self, externalRanges, useExternalRanges)

    def enableExternalRangeScaling(self, useExternalRanges: 'bool const') -> "bool":
        return _GRT.ClassificationDataStream_enableExternalRangeScaling(self, useExternalRanges)

    def scale(self, *args) -> "bool":
        return _GRT.ClassificationDataStream_scale(self, *args)

    def resetPlaybackIndex(self, playbackIndex: 'UINT const') -> "bool":
        return _GRT.ClassificationDataStream_resetPlaybackIndex(self, playbackIndex)

    def getNextSample(self) -> "GRT::ClassificationSample":
        return _GRT.ClassificationDataStream_getNextSample(self)

    def getAllTrainingExamplesWithClassLabel(self, classLabel: 'UINT const') -> "GRT::TimeSeriesClassificationData":
        return _GRT.ClassificationDataStream_getAllTrainingExamplesWithClassLabel(self, classLabel)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationDataStream_save(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationDataStream_load(self, filename)

    def saveDatasetToFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationDataStream_saveDatasetToFile(self, filename)

    def saveDatasetToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationDataStream_saveDatasetToCSVFile(self, filename)

    def loadDatasetFromFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.ClassificationDataStream_loadDatasetFromFile(self, filename)

    def loadDatasetFromCSVFile(self, filename: 'std::string const &', classLabelColumnIndex: 'UINT const'=0) -> "bool":
        return _GRT.ClassificationDataStream_loadDatasetFromCSVFile(self, filename, classLabelColumnIndex)

    def printStats(self) -> "bool":
        return _GRT.ClassificationDataStream_printStats(self)

    def getDatasetName(self) -> "std::string":
        return _GRT.ClassificationDataStream_getDatasetName(self)

    def getInfoText(self) -> "std::string":
        return _GRT.ClassificationDataStream_getInfoText(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.ClassificationDataStream_getNumDimensions(self)

    def getNumSamples(self) -> "UINT":
        return _GRT.ClassificationDataStream_getNumSamples(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.ClassificationDataStream_getNumClasses(self)

    def getMinimumClassLabel(self) -> "UINT":
        return _GRT.ClassificationDataStream_getMinimumClassLabel(self)

    def getMaximumClassLabel(self) -> "UINT":
        return _GRT.ClassificationDataStream_getMaximumClassLabel(self)

    def getClassLabelIndexValue(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.ClassificationDataStream_getClassLabelIndexValue(self, classLabel)

    def getClassNameForCorrespondingClassLabel(self, classLabel: 'UINT const') -> "std::string":
        return _GRT.ClassificationDataStream_getClassNameForCorrespondingClassLabel(self, classLabel)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.ClassificationDataStream_getRanges(self)

    def getClassTracker(self) -> "GRT::Vector< ClassTracker >":
        return _GRT.ClassificationDataStream_getClassTracker(self)

    def getTimeSeriesPositionTracker(self) -> "GRT::Vector< TimeSeriesPositionTracker >":
        return _GRT.ClassificationDataStream_getTimeSeriesPositionTracker(self)

    def getClassificationSamples(self) -> "std::deque< GRT::ClassificationSample >":
        return _GRT.ClassificationDataStream_getClassificationSamples(self)

    def getSubset(self, startIndex: 'UINT const', endIndex: 'UINT const') -> "GRT::ClassificationDataStream":
        return _GRT.ClassificationDataStream_getSubset(self, startIndex, endIndex)

    def getTimeSeriesClassificationData(self, includeNullGestures: 'bool const'=False) -> "GRT::TimeSeriesClassificationData":
        return _GRT.ClassificationDataStream_getTimeSeriesClassificationData(self, includeNullGestures)

    def getClassificationData(self, includeNullGestures: 'bool const'=False) -> "GRT::ClassificationData":
        return _GRT.ClassificationDataStream_getClassificationData(self, includeNullGestures)

    def getTimeSeriesData(self, trackerInfo: 'TimeSeriesPositionTracker const &') -> "GRT::MatrixFloat":
        return _GRT.ClassificationDataStream_getTimeSeriesData(self, trackerInfo)

    def getDataAsMatrixFloat(self) -> "GRT::MatrixFloat":
        return _GRT.ClassificationDataStream_getDataAsMatrixFloat(self)

    def getClassLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.ClassificationDataStream_getClassLabels(self)
ClassificationDataStream_swigregister = _GRT.ClassificationDataStream_swigregister
ClassificationDataStream_swigregister(ClassificationDataStream)

class UnlabelledData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnlabelledData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UnlabelledData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_UnlabelledData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_UnlabelledData
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _GRT.UnlabelledData_clear(self)

    def setNumDimensions(self, numDimensions: 'UINT const') -> "bool":
        return _GRT.UnlabelledData_setNumDimensions(self, numDimensions)

    def setDatasetName(self, datasetName: 'std::string const') -> "bool":
        return _GRT.UnlabelledData_setDatasetName(self, datasetName)

    def setInfoText(self, infoText: 'std::string const') -> "bool":
        return _GRT.UnlabelledData_setInfoText(self, infoText)

    def addSample(self, sample: 'VectorFloat') -> "bool":
        return _GRT.UnlabelledData_addSample(self, sample)

    def removeLastSample(self) -> "bool":
        return _GRT.UnlabelledData_removeLastSample(self)

    def reserve(self, N: 'UINT const') -> "bool":
        return _GRT.UnlabelledData_reserve(self, N)

    def setExternalRanges(self, externalRanges: 'GRT::Vector< MinMax > const &', useExternalRanges: 'bool const'=False) -> "bool":
        return _GRT.UnlabelledData_setExternalRanges(self, externalRanges, useExternalRanges)

    def enableExternalRangeScaling(self, useExternalRanges: 'bool const') -> "bool":
        return _GRT.UnlabelledData_enableExternalRangeScaling(self, useExternalRanges)

    def scale(self, *args) -> "bool":
        return _GRT.UnlabelledData_scale(self, *args)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.UnlabelledData_save(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.UnlabelledData_load(self, filename)

    def saveDatasetToFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.UnlabelledData_saveDatasetToFile(self, filename)

    def loadDatasetFromFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.UnlabelledData_loadDatasetFromFile(self, filename)

    def saveDatasetToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.UnlabelledData_saveDatasetToCSVFile(self, filename)

    def loadDatasetFromCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.UnlabelledData_loadDatasetFromCSVFile(self, filename)

    def partition(self, partitionPercentage: 'UINT const') -> "GRT::UnlabelledData":
        return _GRT.UnlabelledData_partition(self, partitionPercentage)

    def split(self, partitionPercentage: 'UINT const') -> "GRT::UnlabelledData":
        return _GRT.UnlabelledData_split(self, partitionPercentage)

    def merge(self, unlabelledData: 'UnlabelledData') -> "bool":
        return _GRT.UnlabelledData_merge(self, unlabelledData)

    def spiltDataIntoKFolds(self, K: 'UINT const') -> "bool":
        return _GRT.UnlabelledData_spiltDataIntoKFolds(self, K)

    def getTrainingFoldData(self, foldIndex: 'UINT const') -> "GRT::UnlabelledData":
        return _GRT.UnlabelledData_getTrainingFoldData(self, foldIndex)

    def getTestFoldData(self, foldIndex: 'UINT const') -> "GRT::UnlabelledData":
        return _GRT.UnlabelledData_getTestFoldData(self, foldIndex)

    def getDatasetName(self) -> "std::string":
        return _GRT.UnlabelledData_getDatasetName(self)

    def getInfoText(self) -> "std::string":
        return _GRT.UnlabelledData_getInfoText(self)

    def getStatsAsString(self) -> "std::string":
        return _GRT.UnlabelledData_getStatsAsString(self)

    def getNumDimensions(self) -> "UINT":
        return _GRT.UnlabelledData_getNumDimensions(self)

    def getNumSamples(self) -> "UINT":
        return _GRT.UnlabelledData_getNumSamples(self)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.UnlabelledData_getRanges(self)

    def getData(self) -> "GRT::Vector< GRT::VectorFloat >":
        return _GRT.UnlabelledData_getData(self)

    def getDataAsMatrixDouble(self) -> "GRT::MatrixDouble":
        return _GRT.UnlabelledData_getDataAsMatrixDouble(self)

    def getDataAsMatrixFloat(self) -> "GRT::MatrixFloat":
        return _GRT.UnlabelledData_getDataAsMatrixFloat(self)
UnlabelledData_swigregister = _GRT.UnlabelledData_swigregister
UnlabelledData_swigregister(UnlabelledData)

DEFAULT_NULL_LIKELIHOOD_VALUE = _GRT.DEFAULT_NULL_LIKELIHOOD_VALUE
DEFAULT_NULL_DISTANCE_VALUE = _GRT.DEFAULT_NULL_DISTANCE_VALUE
class TrainingResultsObserverManager(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TrainingResultsObserverManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TrainingResultsObserverManager, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_TrainingResultsObserverManager()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TrainingResultsObserverManager
    __del__ = lambda self: None
TrainingResultsObserverManager_swigregister = _GRT.TrainingResultsObserverManager_swigregister
TrainingResultsObserverManager_swigregister(TrainingResultsObserverManager)

class TestResultsObserverManager(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TestResultsObserverManager, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TestResultsObserverManager, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_TestResultsObserverManager()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TestResultsObserverManager
    __del__ = lambda self: None
TestResultsObserverManager_swigregister = _GRT.TestResultsObserverManager_swigregister
TestResultsObserverManager_swigregister(TestResultsObserverManager)

class MLBase(GRTBase):
    __swig_setmethods__ = {}
    for _s in [GRTBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLBase, name, value)
    __swig_getmethods__ = {}
    for _s in [GRTBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLBase, name)
    __repr__ = _swig_repr
    BASE_TYPE_NOT_SET = _GRT.MLBase_BASE_TYPE_NOT_SET
    CLASSIFIER = _GRT.MLBase_CLASSIFIER
    REGRESSIFIER = _GRT.MLBase_REGRESSIFIER
    CLUSTERER = _GRT.MLBase_CLUSTERER
    PRE_PROCSSING = _GRT.MLBase_PRE_PROCSSING
    POST_PROCESSING = _GRT.MLBase_POST_PROCESSING
    FEATURE_EXTRACTION = _GRT.MLBase_FEATURE_EXTRACTION
    CONTEXT = _GRT.MLBase_CONTEXT

    def __init__(self, *args):
        this = _GRT.new_MLBase(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MLBase
    __del__ = lambda self: None

    def copyMLBaseVariables(self, mlBase: 'MLBase') -> "bool":
        return _GRT.MLBase_copyMLBaseVariables(self, mlBase)

    def train(self, *args) -> "bool":
        return _GRT.MLBase_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.MLBase_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.MLBase_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.MLBase_predict_(self, *args)

    def map(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MLBase_map(self, inputVector)

    def map_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MLBase_map_(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.MLBase_reset(self)

    def clear(self) -> "bool":
        return _GRT.MLBase_clear(self)

    def _print(self) -> "bool":
        return _GRT.MLBase__print(self)

    def save(self, *args) -> "bool":
        return _GRT.MLBase_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MLBase_load(self, *args)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.MLBase_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.MLBase_loadModelFromFile(self, *args)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.MLBase_getModel(self, stream)

    def getModelAsString(self) -> "std::string":
        return _GRT.MLBase_getModelAsString(self)

    def getInputType(self) -> "DataType":
        return _GRT.MLBase_getInputType(self)

    def getOutputType(self) -> "DataType":
        return _GRT.MLBase_getOutputType(self)

    def getType(self) -> "GRT::MLBase::BaseType":
        return _GRT.MLBase_getType(self)

    def getNumInputFeatures(self) -> "UINT":
        return _GRT.MLBase_getNumInputFeatures(self)

    def getNumInputDimensions(self) -> "UINT":
        return _GRT.MLBase_getNumInputDimensions(self)

    def getNumOutputDimensions(self) -> "UINT":
        return _GRT.MLBase_getNumOutputDimensions(self)

    def getMinNumEpochs(self) -> "UINT":
        return _GRT.MLBase_getMinNumEpochs(self)

    def getMaxNumEpochs(self) -> "UINT":
        return _GRT.MLBase_getMaxNumEpochs(self)

    def getBatchSize(self) -> "UINT":
        return _GRT.MLBase_getBatchSize(self)

    def getNumRestarts(self) -> "UINT":
        return _GRT.MLBase_getNumRestarts(self)

    def getValidationSetSize(self) -> "UINT":
        return _GRT.MLBase_getValidationSetSize(self)

    def getNumTrainingIterationsToConverge(self) -> "UINT":
        return _GRT.MLBase_getNumTrainingIterationsToConverge(self)

    def getLearningRate(self) -> "GRT::Float":
        return _GRT.MLBase_getLearningRate(self)

    def getRMSTrainingError(self) -> "GRT::Float":
        return _GRT.MLBase_getRMSTrainingError(self)

    def getRootMeanSquaredTrainingError(self) -> "GRT::Float":
        return _GRT.MLBase_getRootMeanSquaredTrainingError(self)

    def getTotalSquaredTrainingError(self) -> "GRT::Float":
        return _GRT.MLBase_getTotalSquaredTrainingError(self)

    def getRMSValidationError(self) -> "GRT::Float":
        return _GRT.MLBase_getRMSValidationError(self)

    def getValidationSetAccuracy(self) -> "GRT::Float":
        return _GRT.MLBase_getValidationSetAccuracy(self)

    def getValidationSetPrecision(self) -> "GRT::VectorFloat":
        return _GRT.MLBase_getValidationSetPrecision(self)

    def getValidationSetRecall(self) -> "GRT::VectorFloat":
        return _GRT.MLBase_getValidationSetRecall(self)

    def getUseValidationSet(self) -> "bool":
        return _GRT.MLBase_getUseValidationSet(self)

    def getTrained(self) -> "bool":
        return _GRT.MLBase_getTrained(self)

    def getModelTrained(self) -> "bool":
        return _GRT.MLBase_getModelTrained(self)

    def getConverged(self) -> "bool":
        return _GRT.MLBase_getConverged(self)

    def getScalingEnabled(self) -> "bool":
        return _GRT.MLBase_getScalingEnabled(self)

    def getIsBaseTypeClassifier(self) -> "bool":
        return _GRT.MLBase_getIsBaseTypeClassifier(self)

    def getIsBaseTypeRegressifier(self) -> "bool":
        return _GRT.MLBase_getIsBaseTypeRegressifier(self)

    def getIsBaseTypeClusterer(self) -> "bool":
        return _GRT.MLBase_getIsBaseTypeClusterer(self)

    def getTrainingLoggingEnabled(self) -> "bool":
        return _GRT.MLBase_getTrainingLoggingEnabled(self)

    def getTestingLoggingEnabled(self) -> "bool":
        return _GRT.MLBase_getTestingLoggingEnabled(self)

    def enableScaling(self, useScaling: 'bool const') -> "bool":
        return _GRT.MLBase_enableScaling(self, useScaling)

    def setMaxNumEpochs(self, maxNumEpochs: 'UINT const') -> "bool":
        return _GRT.MLBase_setMaxNumEpochs(self, maxNumEpochs)

    def setBatchSize(self, batchSize: 'UINT const') -> "bool":
        return _GRT.MLBase_setBatchSize(self, batchSize)

    def setMinNumEpochs(self, minNumEpochs: 'UINT const') -> "bool":
        return _GRT.MLBase_setMinNumEpochs(self, minNumEpochs)

    def setNumRestarts(self, numRestarts: 'UINT const') -> "bool":
        return _GRT.MLBase_setNumRestarts(self, numRestarts)

    def setMinChange(self, minChange: 'GRT::Float const') -> "bool":
        return _GRT.MLBase_setMinChange(self, minChange)

    def setLearningRate(self, learningRate: 'GRT::Float const') -> "bool":
        return _GRT.MLBase_setLearningRate(self, learningRate)

    def setUseValidationSet(self, useValidationSet: 'bool const') -> "bool":
        return _GRT.MLBase_setUseValidationSet(self, useValidationSet)

    def setValidationSetSize(self, validationSetSize: 'UINT const') -> "bool":
        return _GRT.MLBase_setValidationSetSize(self, validationSetSize)

    def setRandomiseTrainingOrder(self, randomiseTrainingOrder: 'bool const') -> "bool":
        return _GRT.MLBase_setRandomiseTrainingOrder(self, randomiseTrainingOrder)

    def setTrainingLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.MLBase_setTrainingLoggingEnabled(self, loggingEnabled)

    def setTestingLoggingEnabled(self, loggingEnabled: 'bool const') -> "bool":
        return _GRT.MLBase_setTestingLoggingEnabled(self, loggingEnabled)

    def registerTrainingResultsObserver(self, observer: 'Observer< TrainingResult > &') -> "bool":
        return _GRT.MLBase_registerTrainingResultsObserver(self, observer)

    def registerTestResultsObserver(self, observer: 'Observer< TestInstanceResult > &') -> "bool":
        return _GRT.MLBase_registerTestResultsObserver(self, observer)

    def removeTrainingResultsObserver(self, observer: 'Observer< TrainingResult > const &') -> "bool":
        return _GRT.MLBase_removeTrainingResultsObserver(self, observer)

    def removeTestResultsObserver(self, observer: 'Observer< TestInstanceResult > const &') -> "bool":
        return _GRT.MLBase_removeTestResultsObserver(self, observer)

    def removeAllTrainingObservers(self) -> "bool":
        return _GRT.MLBase_removeAllTrainingObservers(self)

    def removeAllTestObservers(self) -> "bool":
        return _GRT.MLBase_removeAllTestObservers(self)

    def notifyTrainingResultsObservers(self, data: 'TrainingResult const &') -> "bool":
        return _GRT.MLBase_notifyTrainingResultsObservers(self, data)

    def notifyTestResultsObservers(self, data: 'TestInstanceResult const &') -> "bool":
        return _GRT.MLBase_notifyTestResultsObservers(self, data)

    def getMLBasePointer(self, *args) -> "GRT::MLBase const *":
        return _GRT.MLBase_getMLBasePointer(self, *args)

    def getTrainingResults(self) -> "GRT::Vector< TrainingResult >":
        return _GRT.MLBase_getTrainingResults(self)
MLBase_swigregister = _GRT.MLBase_swigregister
MLBase_swigregister(MLBase)

class Classifier(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Classifier, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Classifier, name)
    __repr__ = _swig_repr
    STANDARD_CLASSIFIER_MODE = _GRT.Classifier_STANDARD_CLASSIFIER_MODE
    TIMESERIES_CLASSIFIER_MODE = _GRT.Classifier_TIMESERIES_CLASSIFIER_MODE

    def __init__(self, *args):
        this = _GRT.new_Classifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Classifier
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.Classifier_deepCopyFrom(self, classifier)

    def copyBaseVariables(self, classifier: 'Classifier') -> "bool":
        return _GRT.Classifier_copyBaseVariables(self, classifier)

    def reset(self) -> "bool":
        return _GRT.Classifier_reset(self)

    def clear(self) -> "bool":
        return _GRT.Classifier_clear(self)

    def computeAccuracy(self, data: 'ClassificationData', accuracy: 'GRT::Float &') -> "bool":
        return _GRT.Classifier_computeAccuracy(self, data, accuracy)

    def getClassifierType(self) -> "std::string":
        return _GRT.Classifier_getClassifierType(self)

    def getSupportsNullRejection(self) -> "bool":
        return _GRT.Classifier_getSupportsNullRejection(self)

    def getNullRejectionEnabled(self) -> "bool":
        return _GRT.Classifier_getNullRejectionEnabled(self)

    def getNullRejectionCoeff(self) -> "GRT::Float":
        return _GRT.Classifier_getNullRejectionCoeff(self)

    def getMaximumLikelihood(self) -> "GRT::Float":
        return _GRT.Classifier_getMaximumLikelihood(self)

    def getBestDistance(self) -> "GRT::Float":
        return _GRT.Classifier_getBestDistance(self)

    def getPhase(self) -> "GRT::Float":
        return _GRT.Classifier_getPhase(self)

    def getTrainingSetAccuracy(self) -> "GRT::Float":
        return _GRT.Classifier_getTrainingSetAccuracy(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.Classifier_getNumClasses(self)

    def getClassLabelIndexValue(self, classLabel: 'UINT const') -> "UINT":
        return _GRT.Classifier_getClassLabelIndexValue(self, classLabel)

    def getPredictedClassLabel(self) -> "UINT":
        return _GRT.Classifier_getPredictedClassLabel(self)

    def getClassLikelihoods(self) -> "GRT::VectorFloat":
        return _GRT.Classifier_getClassLikelihoods(self)

    def getClassDistances(self) -> "GRT::VectorFloat":
        return _GRT.Classifier_getClassDistances(self)

    def getNullRejectionThresholds(self) -> "GRT::VectorFloat":
        return _GRT.Classifier_getNullRejectionThresholds(self)

    def getClassLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.Classifier_getClassLabels(self)

    def getRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.Classifier_getRanges(self)

    def enableNullRejection(self, useNullRejection: 'bool const') -> "bool":
        return _GRT.Classifier_enableNullRejection(self, useNullRejection)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float const') -> "bool":
        return _GRT.Classifier_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setNullRejectionThresholds(self, newRejectionThresholds: 'VectorFloat') -> "bool":
        return _GRT.Classifier_setNullRejectionThresholds(self, newRejectionThresholds)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.Classifier_recomputeNullRejectionThresholds(self)

    def getTimeseriesCompatible(self) -> "bool":
        return _GRT.Classifier_getTimeseriesCompatible(self)

    def create(self, *args) -> "GRT::Classifier *":
        return _GRT.Classifier_create(self, *args)

    def createNewInstance(self) -> "GRT::Classifier *":
        return _GRT.Classifier_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.Classifier_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.Classifier_createInstanceFromString

    def deepCopy(self) -> "GRT::Classifier *":
        return _GRT.Classifier_deepCopy(self)

    def getClassifierPointer(self) -> "GRT::Classifier const *":
        return _GRT.Classifier_getClassifierPointer(self)

    def getBaseClassifier(self) -> "GRT::Classifier const &":
        return _GRT.Classifier_getBaseClassifier(self)
    if _newclass:
        getRegisteredClassifiers = staticmethod(_GRT.Classifier_getRegisteredClassifiers)
    else:
        getRegisteredClassifiers = _GRT.Classifier_getRegisteredClassifiers
Classifier_swigregister = _GRT.Classifier_swigregister
Classifier_swigregister(Classifier)

def Classifier_createInstanceFromString(id: 'std::string const &') -> "GRT::Classifier *":
    return _GRT.Classifier_createInstanceFromString(id)
Classifier_createInstanceFromString = _GRT.Classifier_createInstanceFromString

def Classifier_getRegisteredClassifiers() -> "GRT::Vector< std::string >":
    return _GRT.Classifier_getRegisteredClassifiers()
Classifier_getRegisteredClassifiers = _GRT.Classifier_getRegisteredClassifiers

class PostProcessing(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PostProcessing, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PostProcessing, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_PostProcessing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_PostProcessing
    __del__ = lambda self: None

    def deepCopyFrom(self, postProcessing: 'PostProcessing') -> "bool":
        return _GRT.PostProcessing_deepCopyFrom(self, postProcessing)

    def copyBaseVariables(self, postProcessingModule: 'PostProcessing') -> "bool":
        return _GRT.PostProcessing_copyBaseVariables(self, postProcessingModule)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.PostProcessing_process(self, inputVector)

    def getPostProcessingInputMode(self) -> "UINT":
        return _GRT.PostProcessing_getPostProcessingInputMode(self)

    def getPostProcessingOutputMode(self) -> "UINT":
        return _GRT.PostProcessing_getPostProcessingOutputMode(self)

    def getInitialized(self) -> "bool":
        return _GRT.PostProcessing_getInitialized(self)

    def getIsPostProcessingInputModePredictedClassLabel(self) -> "bool":
        return _GRT.PostProcessing_getIsPostProcessingInputModePredictedClassLabel(self)

    def getIsPostProcessingInputModeClassLikelihoods(self) -> "bool":
        return _GRT.PostProcessing_getIsPostProcessingInputModeClassLikelihoods(self)

    def getIsPostProcessingOutputModePredictedClassLabel(self) -> "bool":
        return _GRT.PostProcessing_getIsPostProcessingOutputModePredictedClassLabel(self)

    def getIsPostProcessingOutputModeClassLikelihoods(self) -> "bool":
        return _GRT.PostProcessing_getIsPostProcessingOutputModeClassLikelihoods(self)

    def getProcessedData(self) -> "GRT::VectorFloat":
        return _GRT.PostProcessing_getProcessedData(self)

    def create(self, *args) -> "GRT::PostProcessing *":
        return _GRT.PostProcessing_create(self, *args)
    INPUT_MODE_NOT_SET = _GRT.PostProcessing_INPUT_MODE_NOT_SET
    INPUT_MODE_PREDICTED_CLASS_LABEL = _GRT.PostProcessing_INPUT_MODE_PREDICTED_CLASS_LABEL
    INPUT_MODE_CLASS_LIKELIHOODS = _GRT.PostProcessing_INPUT_MODE_CLASS_LIKELIHOODS
    OUTPUT_MODE_NOT_SET = _GRT.PostProcessing_OUTPUT_MODE_NOT_SET
    OUTPUT_MODE_PREDICTED_CLASS_LABEL = _GRT.PostProcessing_OUTPUT_MODE_PREDICTED_CLASS_LABEL
    OUTPUT_MODE_CLASS_LIKELIHOODS = _GRT.PostProcessing_OUTPUT_MODE_CLASS_LIKELIHOODS

    def createNewInstance(self) -> "GRT::PostProcessing *":
        return _GRT.PostProcessing_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.PostProcessing_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.PostProcessing_createInstanceFromString

    def getPostProcessingType(self) -> "std::string":
        return _GRT.PostProcessing_getPostProcessingType(self)
PostProcessing_swigregister = _GRT.PostProcessing_swigregister
PostProcessing_swigregister(PostProcessing)

def PostProcessing_createInstanceFromString(id: 'std::string const &') -> "GRT::PostProcessing *":
    return _GRT.PostProcessing_createInstanceFromString(id)
PostProcessing_createInstanceFromString = _GRT.PostProcessing_createInstanceFromString

class Clusterer(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Clusterer, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Clusterer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_Clusterer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Clusterer
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.Clusterer_deepCopyFrom(self, clusterer)

    def copyBaseVariables(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.Clusterer_copyBaseVariables(self, clusterer)

    def train_(self, *args) -> "bool":
        return _GRT.Clusterer_train_(self, *args)

    def reset(self) -> "bool":
        return _GRT.Clusterer_reset(self)

    def clear(self) -> "bool":
        return _GRT.Clusterer_clear(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.Clusterer_getNumClusters(self)

    def getPredictedClusterLabel(self) -> "UINT":
        return _GRT.Clusterer_getPredictedClusterLabel(self)

    def getMaximumLikelihood(self) -> "GRT::Float":
        return _GRT.Clusterer_getMaximumLikelihood(self)

    def getBestDistance(self) -> "GRT::Float":
        return _GRT.Clusterer_getBestDistance(self)

    def getClusterLikelihoods(self) -> "GRT::VectorFloat":
        return _GRT.Clusterer_getClusterLikelihoods(self)

    def getClusterDistances(self) -> "GRT::VectorFloat":
        return _GRT.Clusterer_getClusterDistances(self)

    def getClusterLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.Clusterer_getClusterLabels(self)

    def getClustererType(self) -> "std::string":
        return _GRT.Clusterer_getClustererType(self)

    def setNumClusters(self, numClusters: 'UINT const') -> "bool":
        return _GRT.Clusterer_setNumClusters(self, numClusters)

    def create(self, *args) -> "GRT::Clusterer *":
        return _GRT.Clusterer_create(self, *args)

    def createNewInstance(self) -> "GRT::Clusterer *":
        return _GRT.Clusterer_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.Clusterer_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.Clusterer_createInstanceFromString

    def deepCopy(self) -> "GRT::Clusterer *":
        return _GRT.Clusterer_deepCopy(self)

    def getBaseClusterer(self) -> "GRT::Clusterer const &":
        return _GRT.Clusterer_getBaseClusterer(self)
    if _newclass:
        getRegisteredClusterers = staticmethod(_GRT.Clusterer_getRegisteredClusterers)
    else:
        getRegisteredClusterers = _GRT.Clusterer_getRegisteredClusterers

    def train(self, *args) -> "bool":
        return _GRT.Clusterer_train(self, *args)
Clusterer_swigregister = _GRT.Clusterer_swigregister
Clusterer_swigregister(Clusterer)

def Clusterer_createInstanceFromString(id: 'std::string const &') -> "GRT::Clusterer *":
    return _GRT.Clusterer_createInstanceFromString(id)
Clusterer_createInstanceFromString = _GRT.Clusterer_createInstanceFromString

def Clusterer_getRegisteredClusterers() -> "GRT::Vector< std::string >":
    return _GRT.Clusterer_getRegisteredClusterers()
Clusterer_getRegisteredClusterers = _GRT.Clusterer_getRegisteredClusterers

class FeatureExtraction(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FeatureExtraction, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FeatureExtraction, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_FeatureExtraction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FeatureExtraction
    __del__ = lambda self: None

    def deepCopyFrom(self, rhs: 'FeatureExtraction') -> "bool":
        return _GRT.FeatureExtraction_deepCopyFrom(self, rhs)

    def copyBaseVariables(self, featureExtractionModule: 'FeatureExtraction') -> "bool":
        return _GRT.FeatureExtraction_copyBaseVariables(self, featureExtractionModule)

    def predict(self, *args) -> "bool":
        return _GRT.FeatureExtraction_predict(self, *args)

    def computeFeatures(self, *args) -> "bool":
        return _GRT.FeatureExtraction_computeFeatures(self, *args)

    def clear(self) -> "bool":
        return _GRT.FeatureExtraction_clear(self)

    def getInitialized(self) -> "bool":
        return _GRT.FeatureExtraction_getInitialized(self)

    def getFeatureDataReady(self) -> "bool":
        return _GRT.FeatureExtraction_getFeatureDataReady(self)

    def getIsTrainable(self) -> "bool":
        return _GRT.FeatureExtraction_getIsTrainable(self)

    def getFeatureVector(self) -> "GRT::VectorFloat const &":
        return _GRT.FeatureExtraction_getFeatureVector(self)

    def getFeatureMatrix(self) -> "GRT::MatrixFloat const &":
        return _GRT.FeatureExtraction_getFeatureMatrix(self)

    def create(self, *args) -> "GRT::FeatureExtraction *":
        return _GRT.FeatureExtraction_create(self, *args)

    def save(self, *args) -> "bool":
        return _GRT.FeatureExtraction_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.FeatureExtraction_load(self, *args)

    def createNewInstance(self) -> "GRT::FeatureExtraction *":
        return _GRT.FeatureExtraction_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.FeatureExtraction_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.FeatureExtraction_createInstanceFromString

    def getFeatureExtractionType(self) -> "std::string":
        return _GRT.FeatureExtraction_getFeatureExtractionType(self)
FeatureExtraction_swigregister = _GRT.FeatureExtraction_swigregister
FeatureExtraction_swigregister(FeatureExtraction)

def FeatureExtraction_createInstanceFromString(id: 'std::string const &') -> "GRT::FeatureExtraction *":
    return _GRT.FeatureExtraction_createInstanceFromString(id)
FeatureExtraction_createInstanceFromString = _GRT.FeatureExtraction_createInstanceFromString

class PreProcessing(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreProcessing, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PreProcessing, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_PreProcessing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_PreProcessing
    __del__ = lambda self: None

    def deepCopyFrom(self, rhs: 'PreProcessing') -> "bool":
        return _GRT.PreProcessing_deepCopyFrom(self, rhs)

    def copyBaseVariables(self, preProcessingModule: 'PreProcessing') -> "bool":
        return _GRT.PreProcessing_copyBaseVariables(self, preProcessingModule)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.PreProcessing_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.PreProcessing_reset(self)

    def clear(self) -> "bool":
        return _GRT.PreProcessing_clear(self)

    def getInitialized(self) -> "bool":
        return _GRT.PreProcessing_getInitialized(self)

    def getProcessedData(self) -> "GRT::VectorFloat":
        return _GRT.PreProcessing_getProcessedData(self)

    def create(self, *args) -> "GRT::PreProcessing *":
        return _GRT.PreProcessing_create(self, *args)

    def createNewInstance(self) -> "GRT::PreProcessing *":
        return _GRT.PreProcessing_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.PreProcessing_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.PreProcessing_createInstanceFromString

    def getPreProcessingType(self) -> "std::string":
        return _GRT.PreProcessing_getPreProcessingType(self)
PreProcessing_swigregister = _GRT.PreProcessing_swigregister
PreProcessing_swigregister(PreProcessing)

def PreProcessing_createInstanceFromString(id: 'std::string const &') -> "GRT::PreProcessing *":
    return _GRT.PreProcessing_createInstanceFromString(id)
PreProcessing_createInstanceFromString = _GRT.PreProcessing_createInstanceFromString

class Regressifier(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Regressifier, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Regressifier, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_Regressifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Regressifier
    __del__ = lambda self: None

    def deepCopyFrom(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.Regressifier_deepCopyFrom(self, regressifier)

    def copyBaseVariables(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.Regressifier_copyBaseVariables(self, regressifier)

    def reset(self) -> "bool":
        return _GRT.Regressifier_reset(self)

    def clear(self) -> "bool":
        return _GRT.Regressifier_clear(self)

    def getRegressionData(self) -> "GRT::VectorFloat":
        return _GRT.Regressifier_getRegressionData(self)

    def getInputRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.Regressifier_getInputRanges(self)

    def getOutputRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.Regressifier_getOutputRanges(self)

    def deepCopy(self) -> "GRT::Regressifier *":
        return _GRT.Regressifier_deepCopy(self)

    def getBaseRegressifier(self) -> "GRT::Regressifier const &":
        return _GRT.Regressifier_getBaseRegressifier(self)
    if _newclass:
        getRegisteredRegressifiers = staticmethod(_GRT.Regressifier_getRegisteredRegressifiers)
    else:
        getRegisteredRegressifiers = _GRT.Regressifier_getRegisteredRegressifiers

    def create(self, *args) -> "GRT::Regressifier *":
        return _GRT.Regressifier_create(self, *args)

    def createNewInstance(self) -> "GRT::Regressifier *":
        return _GRT.Regressifier_createNewInstance(self)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.Regressifier_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.Regressifier_createInstanceFromString

    def getRegressifierType(self) -> "std::string":
        return _GRT.Regressifier_getRegressifierType(self)
Regressifier_swigregister = _GRT.Regressifier_swigregister
Regressifier_swigregister(Regressifier)

def Regressifier_getRegisteredRegressifiers() -> "GRT::Vector< std::string >":
    return _GRT.Regressifier_getRegisteredRegressifiers()
Regressifier_getRegisteredRegressifiers = _GRT.Regressifier_getRegisteredRegressifiers

def Regressifier_createInstanceFromString(id: 'std::string const &') -> "GRT::Regressifier *":
    return _GRT.Regressifier_createInstanceFromString(id)
Regressifier_createInstanceFromString = _GRT.Regressifier_createInstanceFromString

INSERT_AT_END_INDEX = _GRT.INSERT_AT_END_INDEX
class GestureRecognitionPipeline(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GestureRecognitionPipeline, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GestureRecognitionPipeline, name)
    __repr__ = _swig_repr
    START_OF_PIPELINE = _GRT.GestureRecognitionPipeline_START_OF_PIPELINE
    AFTER_PREPROCESSING = _GRT.GestureRecognitionPipeline_AFTER_PREPROCESSING
    AFTER_FEATURE_EXTRACTION = _GRT.GestureRecognitionPipeline_AFTER_FEATURE_EXTRACTION
    AFTER_CLASSIFIER = _GRT.GestureRecognitionPipeline_AFTER_CLASSIFIER
    END_OF_PIPELINE = _GRT.GestureRecognitionPipeline_END_OF_PIPELINE
    NUM_CONTEXT_LEVELS = _GRT.GestureRecognitionPipeline_NUM_CONTEXT_LEVELS

    def __init__(self, *args):
        this = _GRT.new_GestureRecognitionPipeline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GestureRecognitionPipeline
    __del__ = lambda self: None

    def __lshift__(self, *args) -> "GRT::GestureRecognitionPipeline &":
        return _GRT.GestureRecognitionPipeline___lshift__(self, *args)

    def test(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_test(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_predict_(self, *args)

    def map_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.GestureRecognitionPipeline_map_(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_reset(self)

    def clear(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_clear(self)

    def clearModel(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_clearModel(self)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_save(self, filename)

    def savePipelineToFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_savePipelineToFile(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_load(self, filename)

    def loadPipelineFromFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_loadPipelineFromFile(self, filename)

    def preProcessData(self, inputVector: 'VectorFloat', computeFeatures: 'bool'=True) -> "bool":
        return _GRT.GestureRecognitionPipeline_preProcessData(self, inputVector, computeFeatures)

    def getIsInitialized(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsInitialized(self)

    def getIsPreProcessingSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPreProcessingSet(self)

    def getIsFeatureExtractionSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsFeatureExtractionSet(self)

    def getIsClassifierSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsClassifierSet(self)

    def getIsRegressifierSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsRegressifierSet(self)

    def getIsClustererSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsClustererSet(self)

    def getIsPostProcessingSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPostProcessingSet(self)

    def getIsContextSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsContextSet(self)

    def getIsPipelineModeSet(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPipelineModeSet(self)

    def getIsPipelineInClassificationMode(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPipelineInClassificationMode(self)

    def getIsPipelineInRegressionMode(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_getIsPipelineInRegressionMode(self)

    def getInputVectorDimensionsSize(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getInputVectorDimensionsSize(self)

    def getOutputVectorDimensionsSize(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getOutputVectorDimensionsSize(self)

    def getNumClassesInModel(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumClassesInModel(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumClasses(self)

    def getNumPreProcessingModules(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumPreProcessingModules(self)

    def getNumFeatureExtractionModules(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumFeatureExtractionModules(self)

    def getNumPostProcessingModules(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumPostProcessingModules(self)

    def getPredictionModuleIndexPosition(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getPredictionModuleIndexPosition(self)

    def getPredictedClassLabel(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getPredictedClassLabel(self)

    def getUnProcessedPredictedClassLabel(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getUnProcessedPredictedClassLabel(self)

    def getNumTrainingSamples(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumTrainingSamples(self)

    def getNumTestSamples(self) -> "UINT":
        return _GRT.GestureRecognitionPipeline_getNumTestSamples(self)

    def getMaximumLikelihood(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getMaximumLikelihood(self)

    def getPhase(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getPhase(self)

    def getTrainingSetAccuracy(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTrainingSetAccuracy(self)

    def getCrossValidationAccuracy(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getCrossValidationAccuracy(self)

    def getTestAccuracy(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestAccuracy(self)

    def getTestRMSError(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestRMSError(self)

    def getTestSSError(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestSSError(self)

    def getTestRejectionPrecision(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestRejectionPrecision(self)

    def getTestRejectionRecall(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestRejectionRecall(self)

    def getTestTime(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTestTime(self)

    def getTrainingTime(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTrainingTime(self)

    def getTrainingRMSError(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTrainingRMSError(self)

    def getTrainingSSError(self) -> "GRT::Float":
        return _GRT.GestureRecognitionPipeline_getTrainingSSError(self)

    def getTestConfusionMatrix(self) -> "GRT::MatrixFloat":
        return _GRT.GestureRecognitionPipeline_getTestConfusionMatrix(self)

    def getTrainingResults(self) -> "GRT::Vector< TrainingResult >":
        return _GRT.GestureRecognitionPipeline_getTrainingResults(self)

    def getTestResults(self) -> "TestResult":
        return _GRT.GestureRecognitionPipeline_getTestResults(self)

    def getTestPrecision(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getTestPrecision(self, *args)

    def getTestRecall(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getTestRecall(self, *args)

    def getTestFMeasure(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getTestFMeasure(self, *args)

    def getClassLikelihoods(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getClassLikelihoods(self)

    def getClassDistances(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getClassDistances(self)

    def getNullRejectionThresholds(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getNullRejectionThresholds(self)

    def getRegressionData(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getRegressionData(self)

    def getUnProcessedRegressionData(self) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getUnProcessedRegressionData(self)

    def getPreProcessedData(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getPreProcessedData(self, *args)

    def getFeatureExtractionData(self, *args) -> "GRT::VectorFloat":
        return _GRT.GestureRecognitionPipeline_getFeatureExtractionData(self, *args)

    def getClassLabels(self) -> "GRT::Vector< UINT >":
        return _GRT.GestureRecognitionPipeline_getClassLabels(self)

    def getTestInstanceResults(self) -> "GRT::Vector< TestInstanceResult >":
        return _GRT.GestureRecognitionPipeline_getTestInstanceResults(self)

    def getCrossValidationResults(self) -> "GRT::Vector< TestResult >":
        return _GRT.GestureRecognitionPipeline_getCrossValidationResults(self)

    def getPreProcessingModule(self, moduleIndex: 'UINT const') -> "GRT::PreProcessing *":
        return _GRT.GestureRecognitionPipeline_getPreProcessingModule(self, moduleIndex)

    def getFeatureExtractionModule(self, moduleIndex: 'UINT const') -> "GRT::FeatureExtraction *":
        return _GRT.GestureRecognitionPipeline_getFeatureExtractionModule(self, moduleIndex)

    def getClassifier(self) -> "GRT::Classifier *":
        return _GRT.GestureRecognitionPipeline_getClassifier(self)

    def getRegressifier(self) -> "GRT::Regressifier *":
        return _GRT.GestureRecognitionPipeline_getRegressifier(self)

    def getClusterer(self) -> "GRT::Clusterer *":
        return _GRT.GestureRecognitionPipeline_getClusterer(self)

    def getPostProcessingModule(self, moduleIndex: 'UINT') -> "GRT::PostProcessing *":
        return _GRT.GestureRecognitionPipeline_getPostProcessingModule(self, moduleIndex)

    def getContextModule(self, contextLevel: 'UINT const', moduleIndex: 'UINT const') -> "Context *":
        return _GRT.GestureRecognitionPipeline_getContextModule(self, contextLevel, moduleIndex)

    def getModelAsString(self) -> "std::string":
        return _GRT.GestureRecognitionPipeline_getModelAsString(self)

    def getPipelineModeAsString(self) -> "std::string":
        return _GRT.GestureRecognitionPipeline_getPipelineModeAsString(self)

    def getInfo(self) -> "std::string":
        return _GRT.GestureRecognitionPipeline_getInfo(self)

    def getPipelineModeFromString(self, pipelineMode: 'std::string') -> "UINT":
        return _GRT.GestureRecognitionPipeline_getPipelineModeFromString(self, pipelineMode)

    def addPreProcessingModule(self, preProcessingModule: 'PreProcessing', insertIndex: 'UINT'=99999) -> "bool":
        return _GRT.GestureRecognitionPipeline_addPreProcessingModule(self, preProcessingModule, insertIndex)

    def setPreProcessingModule(self, preProcessingModule: 'PreProcessing') -> "bool":
        return _GRT.GestureRecognitionPipeline_setPreProcessingModule(self, preProcessingModule)

    def addFeatureExtractionModule(self, featureExtractionModule: 'FeatureExtraction', insertIndex: 'UINT'=99999) -> "bool":
        return _GRT.GestureRecognitionPipeline_addFeatureExtractionModule(self, featureExtractionModule, insertIndex)

    def setFeatureExtractionModule(self, featureExtractionModule: 'FeatureExtraction') -> "bool":
        return _GRT.GestureRecognitionPipeline_setFeatureExtractionModule(self, featureExtractionModule)

    def setClassifier(self, classifier: 'Classifier') -> "bool":
        return _GRT.GestureRecognitionPipeline_setClassifier(self, classifier)

    def setRegressifier(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.GestureRecognitionPipeline_setRegressifier(self, regressifier)

    def setClusterer(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.GestureRecognitionPipeline_setClusterer(self, clusterer)

    def addPostProcessingModule(self, postProcessingModule: 'PostProcessing', insertIndex: 'UINT'=99999) -> "bool":
        return _GRT.GestureRecognitionPipeline_addPostProcessingModule(self, postProcessingModule, insertIndex)

    def setPostProcessingModule(self, postProcessingModule: 'PostProcessing') -> "bool":
        return _GRT.GestureRecognitionPipeline_setPostProcessingModule(self, postProcessingModule)

    def addContextModule(self, contextModule: 'Context const &', contextLevel: 'UINT', insertIndex: 'UINT'=99999) -> "bool":
        return _GRT.GestureRecognitionPipeline_addContextModule(self, contextModule, contextLevel, insertIndex)

    def updateContextModule(self, value: 'bool', contextLevel: 'UINT'=0, moduleIndex: 'UINT'=0) -> "bool":
        return _GRT.GestureRecognitionPipeline_updateContextModule(self, value, contextLevel, moduleIndex)

    def removeAllPreProcessingModules(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeAllPreProcessingModules(self)

    def removePreProcessingModule(self, moduleIndex: 'UINT') -> "bool":
        return _GRT.GestureRecognitionPipeline_removePreProcessingModule(self, moduleIndex)

    def removeAllFeatureExtractionModules(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeAllFeatureExtractionModules(self)

    def removeFeatureExtractionModule(self, moduleIndex: 'UINT') -> "bool":
        return _GRT.GestureRecognitionPipeline_removeFeatureExtractionModule(self, moduleIndex)

    def removeClassifier(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeClassifier(self)

    def removeRegressifier(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeRegressifier(self)

    def removeClusterer(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeClusterer(self)

    def removeAllPostProcessingModules(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeAllPostProcessingModules(self)

    def removePostProcessingModule(self, moduleIndex: 'UINT const') -> "bool":
        return _GRT.GestureRecognitionPipeline_removePostProcessingModule(self, moduleIndex)

    def removeAllContextModules(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_removeAllContextModules(self)

    def removeContextModule(self, contextLevel: 'UINT const', moduleIndex: 'UINT const') -> "bool":
        return _GRT.GestureRecognitionPipeline_removeContextModule(self, contextLevel, moduleIndex)

    def clearAll(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_clearAll(self)

    def clearTestResults(self) -> "bool":
        return _GRT.GestureRecognitionPipeline_clearTestResults(self)

    def setInfo(self, info: 'std::string const &') -> "bool":
        return _GRT.GestureRecognitionPipeline_setInfo(self, info)

    def train(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.GestureRecognitionPipeline_predict(self, *args)
GestureRecognitionPipeline_swigregister = _GRT.GestureRecognitionPipeline_swigregister
GestureRecognitionPipeline_swigregister(GestureRecognitionPipeline)

BIG_DISTANCE = _GRT.BIG_DISTANCE
class KNN(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KNN, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KNN, name)
    __repr__ = _swig_repr
    EUCLIDEAN_DISTANCE = _GRT.KNN_EUCLIDEAN_DISTANCE
    COSINE_DISTANCE = _GRT.KNN_COSINE_DISTANCE
    MANHATTAN_DISTANCE = _GRT.KNN_MANHATTAN_DISTANCE

    def __init__(self, *args):
        this = _GRT.new_KNN(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_KNN
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.KNN_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.KNN_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.KNN_recomputeNullRejectionThresholds(self)

    def getK(self) -> "UINT":
        return _GRT.KNN_getK(self)

    def getDistanceMethod(self) -> "UINT":
        return _GRT.KNN_getDistanceMethod(self)

    def setK(self, K: 'UINT') -> "bool":
        return _GRT.KNN_setK(self, K)

    def setMinKSearchValue(self, minKSearchValue: 'UINT') -> "bool":
        return _GRT.KNN_setMinKSearchValue(self, minKSearchValue)

    def setMaxKSearchValue(self, maxKSearchValue: 'UINT') -> "bool":
        return _GRT.KNN_setMaxKSearchValue(self, maxKSearchValue)

    def enableBestKValueSearch(self, searchForBestKValue: 'bool') -> "bool":
        return _GRT.KNN_enableBestKValueSearch(self, searchForBestKValue)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float') -> "bool":
        return _GRT.KNN_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setDistanceMethod(self, distanceMethod: 'UINT') -> "bool":
        return _GRT.KNN_setDistanceMethod(self, distanceMethod)
    if _newclass:
        getId = staticmethod(_GRT.KNN_getId)
    else:
        getId = _GRT.KNN_getId

    def save(self, *args) -> "bool":
        return _GRT.KNN_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.KNN_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.KNN_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.KNN_predict_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.KNN_predict(self, *args)
KNN_swigregister = _GRT.KNN_swigregister
KNN_swigregister(KNN)

def KNN_getId() -> "std::string":
    return _GRT.KNN_getId()
KNN_getId = _GRT.KNN_getId

WEAK_CLASSIFIER_POSITIVE_CLASS_LABEL = _GRT.WEAK_CLASSIFIER_POSITIVE_CLASS_LABEL
WEAK_CLASSIFIER_NEGATIVE_CLASS_LABEL = _GRT.WEAK_CLASSIFIER_NEGATIVE_CLASS_LABEL
class WeakClassifier(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeakClassifier, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WeakClassifier, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _GRT.delete_WeakClassifier
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _GRT.new_WeakClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copyBaseVariables(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.WeakClassifier_copyBaseVariables(self, weakClassifer)

    def deepCopyFrom(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.WeakClassifier_deepCopyFrom(self, weakClassifer)

    def train(self, trainingData: 'ClassificationData', weights: 'VectorFloat') -> "bool":
        return _GRT.WeakClassifier_train(self, trainingData, weights)

    def predict(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.WeakClassifier_predict(self, x)

    def saveModelToFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.WeakClassifier_saveModelToFile(self, file)

    def loadModelFromFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.WeakClassifier_loadModelFromFile(self, file)

    def _print(self) -> "void":
        return _GRT.WeakClassifier__print(self)

    def getPositiveClassLabel(self) -> "GRT::Float":
        return _GRT.WeakClassifier_getPositiveClassLabel(self)

    def getNegativeClassLabel(self) -> "GRT::Float":
        return _GRT.WeakClassifier_getNegativeClassLabel(self)

    def getWeakClassifierType(self) -> "std::string":
        return _GRT.WeakClassifier_getWeakClassifierType(self)

    def getTrained(self) -> "bool":
        return _GRT.WeakClassifier_getTrained(self)

    def getNumInputDimensions(self) -> "UINT":
        return _GRT.WeakClassifier_getNumInputDimensions(self)

    def getTrainingLoggingEnabled(self) -> "bool":
        return _GRT.WeakClassifier_getTrainingLoggingEnabled(self)

    def setTrainingLoggingEnabled(self, enabled: 'bool const') -> "bool":
        return _GRT.WeakClassifier_setTrainingLoggingEnabled(self, enabled)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.WeakClassifier_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.WeakClassifier_createInstanceFromString

    def createNewInstance(self) -> "GRT::WeakClassifier *":
        return _GRT.WeakClassifier_createNewInstance(self)
WeakClassifier_swigregister = _GRT.WeakClassifier_swigregister
WeakClassifier_swigregister(WeakClassifier)

def WeakClassifier_createInstanceFromString(weakClassifierType: 'std::string const &') -> "GRT::WeakClassifier *":
    return _GRT.WeakClassifier_createInstanceFromString(weakClassifierType)
WeakClassifier_createInstanceFromString = _GRT.WeakClassifier_createInstanceFromString

class DecisionStump(WeakClassifier):
    __swig_setmethods__ = {}
    for _s in [WeakClassifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionStump, name, value)
    __swig_getmethods__ = {}
    for _s in [WeakClassifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionStump, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _GRT.delete_DecisionStump
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _GRT.new_DecisionStump(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def deepCopyFrom(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.DecisionStump_deepCopyFrom(self, weakClassifer)

    def train(self, trainingData: 'ClassificationData', weights: 'VectorFloat') -> "bool":
        return _GRT.DecisionStump_train(self, trainingData, weights)

    def predict(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.DecisionStump_predict(self, x)

    def saveModelToFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.DecisionStump_saveModelToFile(self, file)

    def loadModelFromFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.DecisionStump_loadModelFromFile(self, file)

    def _print(self) -> "void":
        return _GRT.DecisionStump__print(self)

    def getDecisionFeatureIndex(self) -> "UINT":
        return _GRT.DecisionStump_getDecisionFeatureIndex(self)

    def getDirection(self) -> "UINT":
        return _GRT.DecisionStump_getDirection(self)

    def getNumRandomSplits(self) -> "UINT":
        return _GRT.DecisionStump_getNumRandomSplits(self)

    def getDecisionValue(self) -> "GRT::Float":
        return _GRT.DecisionStump_getDecisionValue(self)
DecisionStump_swigregister = _GRT.DecisionStump_swigregister
DecisionStump_swigregister(DecisionStump)

class RadialBasisFunction(WeakClassifier):
    __swig_setmethods__ = {}
    for _s in [WeakClassifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RadialBasisFunction, name, value)
    __swig_getmethods__ = {}
    for _s in [WeakClassifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RadialBasisFunction, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _GRT.delete_RadialBasisFunction
    __del__ = lambda self: None

    def __init__(self, *args):
        this = _GRT.new_RadialBasisFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def deepCopyFrom(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.RadialBasisFunction_deepCopyFrom(self, weakClassifer)

    def train(self, trainingData: 'ClassificationData', weights: 'VectorFloat') -> "bool":
        return _GRT.RadialBasisFunction_train(self, trainingData, weights)

    def predict(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.RadialBasisFunction_predict(self, x)

    def saveModelToFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.RadialBasisFunction_saveModelToFile(self, file)

    def loadModelFromFile(self, file: 'std::fstream &') -> "bool":
        return _GRT.RadialBasisFunction_loadModelFromFile(self, file)

    def _print(self) -> "void":
        return _GRT.RadialBasisFunction__print(self)

    def getNumSteps(self) -> "UINT":
        return _GRT.RadialBasisFunction_getNumSteps(self)

    def getPositiveClassificationThreshold(self) -> "GRT::Float":
        return _GRT.RadialBasisFunction_getPositiveClassificationThreshold(self)

    def getAlpha(self) -> "GRT::Float":
        return _GRT.RadialBasisFunction_getAlpha(self)

    def getMinAlphaSearchRange(self) -> "GRT::Float":
        return _GRT.RadialBasisFunction_getMinAlphaSearchRange(self)

    def getMaxAlphaSearchRange(self) -> "GRT::Float":
        return _GRT.RadialBasisFunction_getMaxAlphaSearchRange(self)

    def getRBFCentre(self) -> "GRT::VectorFloat":
        return _GRT.RadialBasisFunction_getRBFCentre(self)
RadialBasisFunction_swigregister = _GRT.RadialBasisFunction_swigregister
RadialBasisFunction_swigregister(RadialBasisFunction)

class AdaBoost(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AdaBoost, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AdaBoost, name)
    __repr__ = _swig_repr
    MAX_POSITIVE_VALUE = _GRT.AdaBoost_MAX_POSITIVE_VALUE
    MAX_VALUE = _GRT.AdaBoost_MAX_VALUE

    def __init__(self, *args):
        this = _GRT.new_AdaBoost(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_AdaBoost
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.AdaBoost_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.AdaBoost_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.AdaBoost_recomputeNullRejectionThresholds(self)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float') -> "bool":
        return _GRT.AdaBoost_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setWeakClassifier(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.AdaBoost_setWeakClassifier(self, weakClassifer)

    def addWeakClassifier(self, weakClassifer: 'WeakClassifier') -> "bool":
        return _GRT.AdaBoost_addWeakClassifier(self, weakClassifer)

    def clearWeakClassifiers(self) -> "bool":
        return _GRT.AdaBoost_clearWeakClassifiers(self)

    def setNumBoostingIterations(self, numBoostingIterations: 'UINT') -> "bool":
        return _GRT.AdaBoost_setNumBoostingIterations(self, numBoostingIterations)

    def setPredictionMethod(self, predictionMethod: 'UINT') -> "bool":
        return _GRT.AdaBoost_setPredictionMethod(self, predictionMethod)

    def printModel(self) -> "void":
        return _GRT.AdaBoost_printModel(self)

    def getModels(self) -> "GRT::Vector< AdaBoostClassModel >":
        return _GRT.AdaBoost_getModels(self)
    if _newclass:
        getId = staticmethod(_GRT.AdaBoost_getId)
    else:
        getId = _GRT.AdaBoost_getId

    def save(self, *args) -> "bool":
        return _GRT.AdaBoost_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.AdaBoost_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.AdaBoost_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.AdaBoost_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.AdaBoost_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.AdaBoost_predict_(self, *args)
AdaBoost_swigregister = _GRT.AdaBoost_swigregister
AdaBoost_swigregister(AdaBoost)

def AdaBoost_getId() -> "std::string":
    return _GRT.AdaBoost_getId()
AdaBoost_getId = _GRT.AdaBoost_getId

class ANBC_Model(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ANBC_Model, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ANBC_Model, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_ANBC_Model()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ANBC_Model
    __del__ = lambda self: None

    def train(self, classLabel: 'UINT const', trainingData: 'MatrixFloat', weightsVector: 'VectorFloat') -> "bool":
        return _GRT.ANBC_Model_train(self, classLabel, trainingData, weightsVector)

    def predict(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.ANBC_Model_predict(self, x)

    def predictUnnormed(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.ANBC_Model_predictUnnormed(self, x)

    def gauss(self, x: 'GRT::Float const', mu: 'GRT::Float const', sigma: 'GRT::Float const') -> "GRT::Float":
        return _GRT.ANBC_Model_gauss(self, x, mu, sigma)

    def unnormedGauss(self, x: 'GRT::Float const', mu: 'GRT::Float const', sigma: 'GRT::Float const') -> "GRT::Float":
        return _GRT.ANBC_Model_unnormedGauss(self, x, mu, sigma)

    def recomputeThresholdValue(self, gamma: 'GRT::Float const') -> "void":
        return _GRT.ANBC_Model_recomputeThresholdValue(self, gamma)
    __swig_setmethods__["N"] = _GRT.ANBC_Model_N_set
    __swig_getmethods__["N"] = _GRT.ANBC_Model_N_get
    if _newclass:
        N = _swig_property(_GRT.ANBC_Model_N_get, _GRT.ANBC_Model_N_set)
    __swig_setmethods__["classLabel"] = _GRT.ANBC_Model_classLabel_set
    __swig_getmethods__["classLabel"] = _GRT.ANBC_Model_classLabel_get
    if _newclass:
        classLabel = _swig_property(_GRT.ANBC_Model_classLabel_get, _GRT.ANBC_Model_classLabel_set)
    __swig_setmethods__["threshold"] = _GRT.ANBC_Model_threshold_set
    __swig_getmethods__["threshold"] = _GRT.ANBC_Model_threshold_get
    if _newclass:
        threshold = _swig_property(_GRT.ANBC_Model_threshold_get, _GRT.ANBC_Model_threshold_set)
    __swig_setmethods__["gamma"] = _GRT.ANBC_Model_gamma_set
    __swig_getmethods__["gamma"] = _GRT.ANBC_Model_gamma_get
    if _newclass:
        gamma = _swig_property(_GRT.ANBC_Model_gamma_get, _GRT.ANBC_Model_gamma_set)
    __swig_setmethods__["trainingMu"] = _GRT.ANBC_Model_trainingMu_set
    __swig_getmethods__["trainingMu"] = _GRT.ANBC_Model_trainingMu_get
    if _newclass:
        trainingMu = _swig_property(_GRT.ANBC_Model_trainingMu_get, _GRT.ANBC_Model_trainingMu_set)
    __swig_setmethods__["trainingSigma"] = _GRT.ANBC_Model_trainingSigma_set
    __swig_getmethods__["trainingSigma"] = _GRT.ANBC_Model_trainingSigma_get
    if _newclass:
        trainingSigma = _swig_property(_GRT.ANBC_Model_trainingSigma_get, _GRT.ANBC_Model_trainingSigma_set)
    __swig_setmethods__["mu"] = _GRT.ANBC_Model_mu_set
    __swig_getmethods__["mu"] = _GRT.ANBC_Model_mu_get
    if _newclass:
        mu = _swig_property(_GRT.ANBC_Model_mu_get, _GRT.ANBC_Model_mu_set)
    __swig_setmethods__["sigma"] = _GRT.ANBC_Model_sigma_set
    __swig_getmethods__["sigma"] = _GRT.ANBC_Model_sigma_get
    if _newclass:
        sigma = _swig_property(_GRT.ANBC_Model_sigma_get, _GRT.ANBC_Model_sigma_set)
    __swig_setmethods__["weights"] = _GRT.ANBC_Model_weights_set
    __swig_getmethods__["weights"] = _GRT.ANBC_Model_weights_get
    if _newclass:
        weights = _swig_property(_GRT.ANBC_Model_weights_get, _GRT.ANBC_Model_weights_set)
ANBC_Model_swigregister = _GRT.ANBC_Model_swigregister
ANBC_Model_swigregister(ANBC_Model)

MIN_SCALE_VALUE = _GRT.MIN_SCALE_VALUE
MAX_SCALE_VALUE = _GRT.MAX_SCALE_VALUE
class ANBC(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ANBC, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ANBC, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ANBC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ANBC
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.ANBC_deepCopyFrom(self, classifier)

    def reset(self) -> "bool":
        return _GRT.ANBC_reset(self)

    def clear(self) -> "bool":
        return _GRT.ANBC_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.ANBC_recomputeNullRejectionThresholds(self)

    def getNullRejectionThresholds(self) -> "GRT::VectorFloat":
        return _GRT.ANBC_getNullRejectionThresholds(self)

    def getModels(self) -> "GRT::Vector< GRT::ANBC_Model >":
        return _GRT.ANBC_getModels(self)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'double') -> "bool":
        return _GRT.ANBC_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setWeights(self, weightsData: 'ClassificationData') -> "bool":
        return _GRT.ANBC_setWeights(self, weightsData)

    def clearWeights(self) -> "bool":
        return _GRT.ANBC_clearWeights(self)
    if _newclass:
        getId = staticmethod(_GRT.ANBC_getId)
    else:
        getId = _GRT.ANBC_getId

    def save(self, *args) -> "bool":
        return _GRT.ANBC_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.ANBC_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.ANBC_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.ANBC_predict_(self, *args)
ANBC_swigregister = _GRT.ANBC_swigregister
ANBC_swigregister(ANBC)

def ANBC_getId() -> "std::string":
    return _GRT.ANBC_getId()
ANBC_getId = _GRT.ANBC_getId

class BAG(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BAG, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BAG, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_BAG(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_BAG
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.BAG_deepCopyFrom(self, classifier)

    def reset(self) -> "bool":
        return _GRT.BAG_reset(self)

    def clear(self) -> "bool":
        return _GRT.BAG_clear(self)

    def getEnsembleSize(self) -> "UINT":
        return _GRT.BAG_getEnsembleSize(self)

    def getEnsembleWeights(self) -> "GRT::VectorFloat":
        return _GRT.BAG_getEnsembleWeights(self)

    def getEnsemble(self) -> "GRT::Vector< GRT::Classifier * > const":
        return _GRT.BAG_getEnsemble(self)

    def addClassifierToEnsemble(self, classifier: 'Classifier', weight: 'GRT::Float'=1) -> "bool":
        return _GRT.BAG_addClassifierToEnsemble(self, classifier, weight)

    def clearEnsemble(self) -> "bool":
        return _GRT.BAG_clearEnsemble(self)

    def setWeights(self, weights: 'VectorFloat') -> "bool":
        return _GRT.BAG_setWeights(self, weights)
    if _newclass:
        getId = staticmethod(_GRT.BAG_getId)
    else:
        getId = _GRT.BAG_getId

    def save(self, *args) -> "bool":
        return _GRT.BAG_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.BAG_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.BAG_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.BAG_predict_(self, *args)
BAG_swigregister = _GRT.BAG_swigregister
BAG_swigregister(BAG)

def BAG_getId() -> "std::string":
    return _GRT.BAG_getId()
BAG_getId = _GRT.BAG_getId

class Node(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Node, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Node, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_Node(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Node
    __del__ = lambda self: None

    def computeFeatureWeights(self, weights: 'VectorFloat') -> "bool":
        return _GRT.Node_computeFeatureWeights(self, weights)

    def computeLeafNodeWeights(self, weights: 'MatrixFloat') -> "bool":
        return _GRT.Node_computeLeafNodeWeights(self, weights)

    def clear(self) -> "bool":
        return _GRT.Node_clear(self)

    def _print(self) -> "bool":
        return _GRT.Node__print(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.Node_getModel(self, stream)

    def deepCopy(self) -> "GRT::Node *":
        return _GRT.Node_deepCopy(self)

    def getNodeType(self) -> "std::string":
        return _GRT.Node_getNodeType(self)

    def getDepth(self) -> "UINT":
        return _GRT.Node_getDepth(self)

    def getNodeID(self) -> "UINT":
        return _GRT.Node_getNodeID(self)

    def getPredictedNodeID(self) -> "UINT":
        return _GRT.Node_getPredictedNodeID(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.Node_getMaxDepth(self)

    def getIsLeafNode(self) -> "bool":
        return _GRT.Node_getIsLeafNode(self)

    def getHasParent(self) -> "bool":
        return _GRT.Node_getHasParent(self)

    def getHasLeftChild(self) -> "bool":
        return _GRT.Node_getHasLeftChild(self)

    def getHasRightChild(self) -> "bool":
        return _GRT.Node_getHasRightChild(self)

    def getParent(self) -> "GRT::Node *":
        return _GRT.Node_getParent(self)

    def getLeftChild(self) -> "GRT::Node *":
        return _GRT.Node_getLeftChild(self)

    def getRightChild(self) -> "GRT::Node *":
        return _GRT.Node_getRightChild(self)

    def initNode(self, parent: 'Node', depth: 'UINT const', nodeID: 'UINT const', isLeafNode: 'bool const'=False) -> "bool":
        return _GRT.Node_initNode(self, parent, depth, nodeID, isLeafNode)

    def setParent(self, parent: 'Node') -> "bool":
        return _GRT.Node_setParent(self, parent)

    def setLeftChild(self, leftChild: 'Node') -> "bool":
        return _GRT.Node_setLeftChild(self, leftChild)

    def setRightChild(self, rightChild: 'Node') -> "bool":
        return _GRT.Node_setRightChild(self, rightChild)

    def setDepth(self, depth: 'UINT const') -> "bool":
        return _GRT.Node_setDepth(self, depth)

    def setNodeID(self, nodeID: 'UINT const') -> "bool":
        return _GRT.Node_setNodeID(self, nodeID)

    def setIsLeafNode(self, isLeafNode: 'bool const') -> "bool":
        return _GRT.Node_setIsLeafNode(self, isLeafNode)
    if _newclass:
        createInstanceFromString = staticmethod(_GRT.Node_createInstanceFromString)
    else:
        createInstanceFromString = _GRT.Node_createInstanceFromString

    def createNewInstance(self) -> "GRT::Node *":
        return _GRT.Node_createNewInstance(self)

    def save(self, *args) -> "bool":
        return _GRT.Node_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.Node_load(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.Node_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.Node_predict_(self, *args)
Node_swigregister = _GRT.Node_swigregister
Node_swigregister(Node)

def Node_createInstanceFromString(nodeType: 'std::string const &') -> "GRT::Node *":
    return _GRT.Node_createInstanceFromString(nodeType)
Node_createInstanceFromString = _GRT.Node_createInstanceFromString

class Tree(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tree, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Tree, name)
    __repr__ = _swig_repr
    BEST_ITERATIVE_SPILT = _GRT.Tree_BEST_ITERATIVE_SPILT
    BEST_RANDOM_SPLIT = _GRT.Tree_BEST_RANDOM_SPLIT
    NUM_TRAINING_MODES = _GRT.Tree_NUM_TRAINING_MODES

    def __init__(self, *args):
        this = _GRT.new_Tree(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Tree
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.Tree_clear(self)

    def _print(self) -> "bool":
        return _GRT.Tree__print(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.Tree_getModel(self, stream)

    def deepCopyTree(self) -> "GRT::Node *":
        return _GRT.Tree_deepCopyTree(self)

    def getTree(self) -> "GRT::Node const *":
        return _GRT.Tree_getTree(self)

    def getTrainingMode(self) -> "UINT":
        return _GRT.Tree_getTrainingMode(self)

    def getNumSplittingSteps(self) -> "UINT":
        return _GRT.Tree_getNumSplittingSteps(self)

    def getMinNumSamplesPerNode(self) -> "UINT":
        return _GRT.Tree_getMinNumSamplesPerNode(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.Tree_getMaxDepth(self)

    def getPredictedNodeID(self) -> "UINT":
        return _GRT.Tree_getPredictedNodeID(self)

    def getRemoveFeaturesAtEachSpilt(self) -> "bool":
        return _GRT.Tree_getRemoveFeaturesAtEachSpilt(self)

    def setTrainingMode(self, trainingMode: 'GRT::Tree::TrainingMode const') -> "bool":
        return _GRT.Tree_setTrainingMode(self, trainingMode)

    def setNumSplittingSteps(self, numSplittingSteps: 'UINT const') -> "bool":
        return _GRT.Tree_setNumSplittingSteps(self, numSplittingSteps)

    def setMinNumSamplesPerNode(self, minNumSamplesPerNode: 'UINT const') -> "bool":
        return _GRT.Tree_setMinNumSamplesPerNode(self, minNumSamplesPerNode)

    def setMaxDepth(self, maxDepth: 'UINT const') -> "bool":
        return _GRT.Tree_setMaxDepth(self, maxDepth)

    def setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt: 'bool const') -> "bool":
        return _GRT.Tree_setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt)
Tree_swigregister = _GRT.Tree_swigregister
Tree_swigregister(Tree)

class DecisionTreeNode(Node):
    __swig_setmethods__ = {}
    for _s in [Node]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTreeNode, name, value)
    __swig_getmethods__ = {}
    for _s in [Node]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTreeNode, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_DecisionTreeNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTreeNode
    __del__ = lambda self: None

    def computeBestSplit(self, trainingMode: 'UINT const &', numSplittingSteps: 'UINT const &', trainingData: 'ClassificationData', features: 'VectorTUINT', classLabels: 'VectorTUINT', featureIndex: 'UINT &', minError: 'GRT::Float &') -> "bool":
        return _GRT.DecisionTreeNode_computeBestSplit(self, trainingMode, numSplittingSteps, trainingData, features, classLabels, featureIndex, minError)

    def clear(self) -> "bool":
        return _GRT.DecisionTreeNode_clear(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTreeNode_getModel(self, stream)

    def deepCopy(self) -> "GRT::Node *":
        return _GRT.DecisionTreeNode_deepCopy(self)

    def getNodeSize(self) -> "UINT":
        return _GRT.DecisionTreeNode_getNodeSize(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.DecisionTreeNode_getNumClasses(self)

    def getClassProbabilities(self) -> "GRT::VectorFloat":
        return _GRT.DecisionTreeNode_getClassProbabilities(self)

    def setLeafNode(self, nodeSize: 'UINT const', classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeNode_setLeafNode(self, nodeSize, classProbabilities)

    def setNodeSize(self, nodeSize: 'UINT const') -> "bool":
        return _GRT.DecisionTreeNode_setNodeSize(self, nodeSize)

    def setClassProbabilities(self, classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeNode_setClassProbabilities(self, classProbabilities)
    if _newclass:
        getClassLabelIndexValue = staticmethod(_GRT.DecisionTreeNode_getClassLabelIndexValue)
    else:
        getClassLabelIndexValue = _GRT.DecisionTreeNode_getClassLabelIndexValue

    def predict(self, *args) -> "bool":
        return _GRT.DecisionTreeNode_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTreeNode_predict_(self, *args)
DecisionTreeNode_swigregister = _GRT.DecisionTreeNode_swigregister
DecisionTreeNode_swigregister(DecisionTreeNode)

def DecisionTreeNode_getClassLabelIndexValue(classLabel: 'UINT', classLabels: 'VectorTUINT') -> "UINT":
    return _GRT.DecisionTreeNode_getClassLabelIndexValue(classLabel, classLabels)
DecisionTreeNode_getClassLabelIndexValue = _GRT.DecisionTreeNode_getClassLabelIndexValue

class DecisionTreeThresholdNode(DecisionTreeNode):
    __swig_setmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTreeThresholdNode, name, value)
    __swig_getmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTreeThresholdNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_DecisionTreeThresholdNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTreeThresholdNode
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.DecisionTreeThresholdNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.DecisionTreeThresholdNode__print(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTreeThresholdNode_getModel(self, stream)

    def deepCopy(self) -> "GRT::Node *":
        return _GRT.DecisionTreeThresholdNode_deepCopy(self)

    def getFeatureIndex(self) -> "UINT":
        return _GRT.DecisionTreeThresholdNode_getFeatureIndex(self)

    def getThreshold(self) -> "GRT::Float":
        return _GRT.DecisionTreeThresholdNode_getThreshold(self)

    def set(self, nodeSize: 'UINT const', featureIndex: 'UINT const', threshold: 'GRT::Float const', classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeThresholdNode_set(self, nodeSize, featureIndex, threshold, classProbabilities)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTreeThresholdNode_predict_(self, *args)
DecisionTreeThresholdNode_swigregister = _GRT.DecisionTreeThresholdNode_swigregister
DecisionTreeThresholdNode_swigregister(DecisionTreeThresholdNode)

class DecisionTreeTripleFeatureNode(DecisionTreeNode):
    __swig_setmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTreeTripleFeatureNode, name, value)
    __swig_getmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTreeTripleFeatureNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_DecisionTreeTripleFeatureNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTreeTripleFeatureNode
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode__print(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode_getModel(self, stream)

    def deepCopy(self) -> "GRT::Node *":
        return _GRT.DecisionTreeTripleFeatureNode_deepCopy(self)

    def getFeatureIndexA(self) -> "UINT":
        return _GRT.DecisionTreeTripleFeatureNode_getFeatureIndexA(self)

    def getFeatureIndexB(self) -> "UINT":
        return _GRT.DecisionTreeTripleFeatureNode_getFeatureIndexB(self)

    def getFeatureIndexC(self) -> "UINT":
        return _GRT.DecisionTreeTripleFeatureNode_getFeatureIndexC(self)

    def set(self, nodeSize: 'UINT const', featureIndexA: 'UINT const', featureIndexB: 'UINT const', featureIndexC: 'UINT const', classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode_set(self, nodeSize, featureIndexA, featureIndexB, featureIndexC, classProbabilities)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTreeTripleFeatureNode_predict_(self, *args)
DecisionTreeTripleFeatureNode_swigregister = _GRT.DecisionTreeTripleFeatureNode_swigregister
DecisionTreeTripleFeatureNode_swigregister(DecisionTreeTripleFeatureNode)

class DecisionTreeClusterNode(DecisionTreeNode):
    __swig_setmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTreeClusterNode, name, value)
    __swig_getmethods__ = {}
    for _s in [DecisionTreeNode]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTreeClusterNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_DecisionTreeClusterNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTreeClusterNode
    __del__ = lambda self: None

    def clear(self) -> "bool":
        return _GRT.DecisionTreeClusterNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.DecisionTreeClusterNode__print(self)

    def computeFeatureWeights(self, weights: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeClusterNode_computeFeatureWeights(self, weights)

    def computeLeafNodeWeights(self, weights: 'MatrixFloat') -> "bool":
        return _GRT.DecisionTreeClusterNode_computeLeafNodeWeights(self, weights)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTreeClusterNode_getModel(self, stream)

    def deepCopy(self) -> "GRT::Node *":
        return _GRT.DecisionTreeClusterNode_deepCopy(self)

    def getFeatureIndex(self) -> "UINT":
        return _GRT.DecisionTreeClusterNode_getFeatureIndex(self)

    def getThreshold(self) -> "GRT::Float":
        return _GRT.DecisionTreeClusterNode_getThreshold(self)

    def set(self, nodeSize: 'UINT const', featureIndex: 'UINT const', threshold: 'GRT::Float const', classProbabilities: 'VectorFloat') -> "bool":
        return _GRT.DecisionTreeClusterNode_set(self, nodeSize, featureIndex, threshold, classProbabilities)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTreeClusterNode_predict_(self, *args)
DecisionTreeClusterNode_swigregister = _GRT.DecisionTreeClusterNode_swigregister
DecisionTreeClusterNode_swigregister(DecisionTreeClusterNode)

class DecisionTree(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecisionTree, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecisionTree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_DecisionTree(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DecisionTree
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.DecisionTree_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.DecisionTree_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.DecisionTree_recomputeNullRejectionThresholds(self)

    def getModel(self, stream: 'std::ostream &') -> "bool":
        return _GRT.DecisionTree_getModel(self, stream)

    def deepCopyTree(self) -> "GRT::DecisionTreeNode *":
        return _GRT.DecisionTree_deepCopyTree(self)

    def deepCopyDecisionTreeNode(self) -> "GRT::DecisionTreeNode *":
        return _GRT.DecisionTree_deepCopyDecisionTreeNode(self)

    def getTree(self) -> "GRT::DecisionTreeNode const *":
        return _GRT.DecisionTree_getTree(self)

    def getTrainingMode(self) -> "GRT::Tree::TrainingMode":
        return _GRT.DecisionTree_getTrainingMode(self)

    def getNumSplittingSteps(self) -> "UINT":
        return _GRT.DecisionTree_getNumSplittingSteps(self)

    def getMinNumSamplesPerNode(self) -> "UINT":
        return _GRT.DecisionTree_getMinNumSamplesPerNode(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.DecisionTree_getMaxDepth(self)

    def getPredictedNodeID(self) -> "UINT":
        return _GRT.DecisionTree_getPredictedNodeID(self)

    def getRemoveFeaturesAtEachSplit(self) -> "bool":
        return _GRT.DecisionTree_getRemoveFeaturesAtEachSplit(self)

    def setTrainingMode(self, trainingMode: 'GRT::Tree::TrainingMode const') -> "bool":
        return _GRT.DecisionTree_setTrainingMode(self, trainingMode)

    def setNumSplittingSteps(self, numSplittingSteps: 'UINT const') -> "bool":
        return _GRT.DecisionTree_setNumSplittingSteps(self, numSplittingSteps)

    def setMinNumSamplesPerNode(self, minNumSamplesPerNode: 'UINT const') -> "bool":
        return _GRT.DecisionTree_setMinNumSamplesPerNode(self, minNumSamplesPerNode)

    def setMaxDepth(self, maxDepth: 'UINT const') -> "bool":
        return _GRT.DecisionTree_setMaxDepth(self, maxDepth)

    def setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit: 'bool const') -> "bool":
        return _GRT.DecisionTree_setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit)

    def setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt: 'bool const') -> "bool":
        return _GRT.DecisionTree_setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt)

    def setDecisionTreeNode(self, node: 'DecisionTreeNode') -> "bool":
        return _GRT.DecisionTree_setDecisionTreeNode(self, node)
    if _newclass:
        getId = staticmethod(_GRT.DecisionTree_getId)
    else:
        getId = _GRT.DecisionTree_getId

    def save(self, *args) -> "bool":
        return _GRT.DecisionTree_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.DecisionTree_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.DecisionTree_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.DecisionTree_predict_(self, *args)
DecisionTree_swigregister = _GRT.DecisionTree_swigregister
DecisionTree_swigregister(DecisionTree)

def DecisionTree_getId() -> "std::string":
    return _GRT.DecisionTree_getId()
DecisionTree_getId = _GRT.DecisionTree_getId

class IndexDist(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IndexDist, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IndexDist, name)
    __repr__ = _swig_repr

    def __init__(self, x: 'int'=0, y: 'int'=0, dist: 'GRT::Float'=0):
        this = _GRT.new_IndexDist(x, y, dist)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_IndexDist
    __del__ = lambda self: None
    __swig_setmethods__["x"] = _GRT.IndexDist_x_set
    __swig_getmethods__["x"] = _GRT.IndexDist_x_get
    if _newclass:
        x = _swig_property(_GRT.IndexDist_x_get, _GRT.IndexDist_x_set)
    __swig_setmethods__["y"] = _GRT.IndexDist_y_set
    __swig_getmethods__["y"] = _GRT.IndexDist_y_get
    if _newclass:
        y = _swig_property(_GRT.IndexDist_y_get, _GRT.IndexDist_y_set)
    __swig_setmethods__["dist"] = _GRT.IndexDist_dist_set
    __swig_getmethods__["dist"] = _GRT.IndexDist_dist_get
    if _newclass:
        dist = _swig_property(_GRT.IndexDist_dist_get, _GRT.IndexDist_dist_set)
IndexDist_swigregister = _GRT.IndexDist_swigregister
IndexDist_swigregister(IndexDist)

class DTWTemplate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DTWTemplate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DTWTemplate, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_DTWTemplate()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DTWTemplate
    __del__ = lambda self: None
    __swig_setmethods__["classLabel"] = _GRT.DTWTemplate_classLabel_set
    __swig_getmethods__["classLabel"] = _GRT.DTWTemplate_classLabel_get
    if _newclass:
        classLabel = _swig_property(_GRT.DTWTemplate_classLabel_get, _GRT.DTWTemplate_classLabel_set)
    __swig_setmethods__["timeSeries"] = _GRT.DTWTemplate_timeSeries_set
    __swig_getmethods__["timeSeries"] = _GRT.DTWTemplate_timeSeries_get
    if _newclass:
        timeSeries = _swig_property(_GRT.DTWTemplate_timeSeries_get, _GRT.DTWTemplate_timeSeries_set)
    __swig_setmethods__["trainingMu"] = _GRT.DTWTemplate_trainingMu_set
    __swig_getmethods__["trainingMu"] = _GRT.DTWTemplate_trainingMu_get
    if _newclass:
        trainingMu = _swig_property(_GRT.DTWTemplate_trainingMu_get, _GRT.DTWTemplate_trainingMu_set)
    __swig_setmethods__["trainingSigma"] = _GRT.DTWTemplate_trainingSigma_set
    __swig_getmethods__["trainingSigma"] = _GRT.DTWTemplate_trainingSigma_get
    if _newclass:
        trainingSigma = _swig_property(_GRT.DTWTemplate_trainingSigma_get, _GRT.DTWTemplate_trainingSigma_set)
    __swig_setmethods__["averageTemplateLength"] = _GRT.DTWTemplate_averageTemplateLength_set
    __swig_getmethods__["averageTemplateLength"] = _GRT.DTWTemplate_averageTemplateLength_get
    if _newclass:
        averageTemplateLength = _swig_property(_GRT.DTWTemplate_averageTemplateLength_get, _GRT.DTWTemplate_averageTemplateLength_set)
DTWTemplate_swigregister = _GRT.DTWTemplate_swigregister
DTWTemplate_swigregister(DTWTemplate)

class DTW(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DTW, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DTW, name)
    __repr__ = _swig_repr
    ABSOLUTE_DIST = _GRT.DTW_ABSOLUTE_DIST
    EUCLIDEAN_DIST = _GRT.DTW_EUCLIDEAN_DIST
    NORM_ABSOLUTE_DIST = _GRT.DTW_NORM_ABSOLUTE_DIST
    TEMPLATE_THRESHOLDS = _GRT.DTW_TEMPLATE_THRESHOLDS
    CLASS_LIKELIHOODS = _GRT.DTW_CLASS_LIKELIHOODS
    THRESHOLDS_AND_LIKELIHOODS = _GRT.DTW_THRESHOLDS_AND_LIKELIHOODS

    def __init__(self, *args):
        this = _GRT.new_DTW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DTW
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.DTW_deepCopyFrom(self, classifier)

    def predict_(self, *args) -> "bool":
        return _GRT.DTW_predict_(self, *args)

    def reset(self) -> "bool":
        return _GRT.DTW_reset(self)

    def clear(self) -> "bool":
        return _GRT.DTW_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.DTW_recomputeNullRejectionThresholds(self)

    def getNumTemplates(self) -> "UINT":
        return _GRT.DTW_getNumTemplates(self)

    def setRejectionMode(self, rejectionMode: 'UINT') -> "bool":
        return _GRT.DTW_setRejectionMode(self, rejectionMode)

    def setNullRejectionThreshold(self, nullRejectionLikelihoodThreshold: 'GRT::Float') -> "bool":
        return _GRT.DTW_setNullRejectionThreshold(self, nullRejectionLikelihoodThreshold)

    def setOffsetTimeseriesUsingFirstSample(self, offsetUsingFirstSample: 'bool') -> "bool":
        return _GRT.DTW_setOffsetTimeseriesUsingFirstSample(self, offsetUsingFirstSample)

    def setContrainWarpingPath(self, constrain: 'bool') -> "bool":
        return _GRT.DTW_setContrainWarpingPath(self, constrain)

    def setWarpingRadius(self, radius: 'GRT::Float') -> "bool":
        return _GRT.DTW_setWarpingRadius(self, radius)

    def getRejectionMode(self) -> "UINT":
        return _GRT.DTW_getRejectionMode(self)

    def enableZNormalization(self, useZNormalization: 'bool', constrainZNorm: 'bool'=True) -> "bool":
        return _GRT.DTW_enableZNormalization(self, useZNormalization, constrainZNorm)

    def enableTrimTrainingData(self, trimTrainingData: 'bool', trimThreshold: 'GRT::Float', maximumTrimPercentage: 'GRT::Float') -> "bool":
        return _GRT.DTW_enableTrimTrainingData(self, trimTrainingData, trimThreshold, maximumTrimPercentage)

    def getModels(self) -> "GRT::Vector< GRT::DTWTemplate >":
        return _GRT.DTW_getModels(self)

    def setModels(self, newTemplates: 'GRT::Vector< GRT::DTWTemplate >') -> "bool":
        return _GRT.DTW_setModels(self, newTemplates)

    def getInputDataBuffer(self) -> "GRT::Vector< GRT::VectorFloat >":
        return _GRT.DTW_getInputDataBuffer(self)

    def getDistanceMatrices(self) -> "GRT::Vector< GRT::MatrixFloat > const &":
        return _GRT.DTW_getDistanceMatrices(self)

    def getWarpingPaths(self) -> "GRT::Vector< GRT::Vector< GRT::IndexDist > > const &":
        return _GRT.DTW_getWarpingPaths(self)
    if _newclass:
        getId = staticmethod(_GRT.DTW_getId)
    else:
        getId = _GRT.DTW_getId

    def save(self, *args) -> "bool":
        return _GRT.DTW_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.DTW_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.DTW_train_(self, *args)
DTW_swigregister = _GRT.DTW_swigregister
DTW_swigregister(DTW)

def DTW_getId() -> "std::string":
    return _GRT.DTW_getId()
DTW_getId = _GRT.DTW_getId

class Particle(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Particle, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Particle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_Particle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Particle
    __del__ = lambda self: None
    __swig_setmethods__["w"] = _GRT.Particle_w_set
    __swig_getmethods__["w"] = _GRT.Particle_w_get
    if _newclass:
        w = _swig_property(_GRT.Particle_w_get, _GRT.Particle_w_set)
    __swig_setmethods__["x"] = _GRT.Particle_x_set
    __swig_getmethods__["x"] = _GRT.Particle_x_get
    if _newclass:
        x = _swig_property(_GRT.Particle_x_get, _GRT.Particle_x_set)
Particle_swigregister = _GRT.Particle_swigregister
Particle_swigregister(Particle)

class FSMParticle(Particle):
    __swig_setmethods__ = {}
    for _s in [Particle]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FSMParticle, name, value)
    __swig_getmethods__ = {}
    for _s in [Particle]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FSMParticle, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_FSMParticle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FSMParticle
    __del__ = lambda self: None
    __swig_setmethods__["currentState"] = _GRT.FSMParticle_currentState_set
    __swig_getmethods__["currentState"] = _GRT.FSMParticle_currentState_get
    if _newclass:
        currentState = _swig_property(_GRT.FSMParticle_currentState_get, _GRT.FSMParticle_currentState_set)
FSMParticle_swigregister = _GRT.FSMParticle_swigregister
FSMParticle_swigregister(FSMParticle)

class FiniteStateMachine(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FiniteStateMachine, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FiniteStateMachine, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_FiniteStateMachine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FiniteStateMachine
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.FiniteStateMachine_deepCopyFrom(self, classifier)

    def reset(self) -> "bool":
        return _GRT.FiniteStateMachine_reset(self)

    def clear(self) -> "bool":
        return _GRT.FiniteStateMachine_clear(self)

    def _print(self) -> "bool":
        return _GRT.FiniteStateMachine__print(self)

    def setNumParticles(self, numParticles: 'UINT const') -> "bool":
        return _GRT.FiniteStateMachine_setNumParticles(self, numParticles)

    def setNumClustersPerState(self, numClustersPerState: 'UINT const') -> "bool":
        return _GRT.FiniteStateMachine_setNumClustersPerState(self, numClustersPerState)

    def setStateTransitionSmoothingCoeff(self, stateTransitionSmoothingCoeff: 'GRT::Float const') -> "bool":
        return _GRT.FiniteStateMachine_setStateTransitionSmoothingCoeff(self, stateTransitionSmoothingCoeff)

    def setMeasurementNoise(self, measurementNoise: 'GRT::Float const') -> "bool":
        return _GRT.FiniteStateMachine_setMeasurementNoise(self, measurementNoise)
    if _newclass:
        getId = staticmethod(_GRT.FiniteStateMachine_getId)
    else:
        getId = _GRT.FiniteStateMachine_getId

    def save(self, *args) -> "bool":
        return _GRT.FiniteStateMachine_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.FiniteStateMachine_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.FiniteStateMachine_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.FiniteStateMachine_predict_(self, *args)
FiniteStateMachine_swigregister = _GRT.FiniteStateMachine_swigregister
FiniteStateMachine_swigregister(FiniteStateMachine)

def FiniteStateMachine_getId() -> "std::string":
    return _GRT.FiniteStateMachine_getId()
FiniteStateMachine_getId = _GRT.FiniteStateMachine_getId

class GuassModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GuassModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GuassModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_GuassModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GuassModel
    __del__ = lambda self: None

    def printModelValues(self) -> "bool":
        return _GRT.GuassModel_printModelValues(self)
    __swig_setmethods__["det"] = _GRT.GuassModel_det_set
    __swig_getmethods__["det"] = _GRT.GuassModel_det_get
    if _newclass:
        det = _swig_property(_GRT.GuassModel_det_get, _GRT.GuassModel_det_set)
    __swig_setmethods__["mu"] = _GRT.GuassModel_mu_set
    __swig_getmethods__["mu"] = _GRT.GuassModel_mu_get
    if _newclass:
        mu = _swig_property(_GRT.GuassModel_mu_get, _GRT.GuassModel_mu_set)
    __swig_setmethods__["sigma"] = _GRT.GuassModel_sigma_set
    __swig_getmethods__["sigma"] = _GRT.GuassModel_sigma_get
    if _newclass:
        sigma = _swig_property(_GRT.GuassModel_sigma_get, _GRT.GuassModel_sigma_set)
    __swig_setmethods__["invSigma"] = _GRT.GuassModel_invSigma_set
    __swig_getmethods__["invSigma"] = _GRT.GuassModel_invSigma_get
    if _newclass:
        invSigma = _swig_property(_GRT.GuassModel_invSigma_get, _GRT.GuassModel_invSigma_set)
GuassModel_swigregister = _GRT.GuassModel_swigregister
GuassModel_swigregister(GuassModel)

class MixtureModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MixtureModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MixtureModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_MixtureModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MixtureModel
    __del__ = lambda self: None

    def computeMixtureLikelihood(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.MixtureModel_computeMixtureLikelihood(self, x)

    def resize(self, K: 'UINT') -> "bool":
        return _GRT.MixtureModel_resize(self, K)

    def recomputeNullRejectionThreshold(self, gamma: 'GRT::Float') -> "bool":
        return _GRT.MixtureModel_recomputeNullRejectionThreshold(self, gamma)

    def recomputeNormalizationFactor(self) -> "bool":
        return _GRT.MixtureModel_recomputeNormalizationFactor(self)

    def printModelValues(self) -> "bool":
        return _GRT.MixtureModel_printModelValues(self)

    def getK(self) -> "UINT":
        return _GRT.MixtureModel_getK(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.MixtureModel_getClassLabel(self)

    def getTrainingMu(self) -> "GRT::Float":
        return _GRT.MixtureModel_getTrainingMu(self)

    def getTrainingSigma(self) -> "GRT::Float":
        return _GRT.MixtureModel_getTrainingSigma(self)

    def getNullRejectionThreshold(self) -> "GRT::Float":
        return _GRT.MixtureModel_getNullRejectionThreshold(self)

    def getNormalizationFactor(self) -> "GRT::Float":
        return _GRT.MixtureModel_getNormalizationFactor(self)

    def setClassLabel(self, classLabel: 'UINT const') -> "bool":
        return _GRT.MixtureModel_setClassLabel(self, classLabel)

    def setNormalizationFactor(self, normFactor: 'GRT::Float const') -> "bool":
        return _GRT.MixtureModel_setNormalizationFactor(self, normFactor)

    def setTrainingMuAndSigma(self, trainingMu: 'GRT::Float const', trainingSigma: 'GRT::Float const') -> "bool":
        return _GRT.MixtureModel_setTrainingMuAndSigma(self, trainingMu, trainingSigma)

    def setNullRejectionThreshold(self, nullRejectionThreshold: 'GRT::Float const') -> "bool":
        return _GRT.MixtureModel_setNullRejectionThreshold(self, nullRejectionThreshold)
MixtureModel_swigregister = _GRT.MixtureModel_swigregister
MixtureModel_swigregister(MixtureModel)

GMM_MIN_SCALE_VALUE = _GRT.GMM_MIN_SCALE_VALUE
GMM_MAX_SCALE_VALUE = _GRT.GMM_MAX_SCALE_VALUE
class GMM(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_GMM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GMM
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.GMM_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.GMM_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.GMM_recomputeNullRejectionThresholds(self)

    def getNumMixtureModels(self) -> "UINT":
        return _GRT.GMM_getNumMixtureModels(self)

    def getModels(self) -> "GRT::Vector< GRT::MixtureModel >":
        return _GRT.GMM_getModels(self)

    def setNumMixtureModels(self, K: 'UINT const') -> "bool":
        return _GRT.GMM_setNumMixtureModels(self, K)

    def setMaxIter(self, maxIter: 'UINT') -> "bool":
        return _GRT.GMM_setMaxIter(self, maxIter)
    if _newclass:
        getId = staticmethod(_GRT.GMM_getId)
    else:
        getId = _GRT.GMM_getId

    def save(self, *args) -> "bool":
        return _GRT.GMM_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.GMM_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.GMM_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.GMM_predict_(self, *args)
GMM_swigregister = _GRT.GMM_swigregister
GMM_swigregister(GMM)

def GMM_getId() -> "std::string":
    return _GRT.GMM_getId()
GMM_getId = _GRT.GMM_getId

HMM_ERGODIC = _GRT.HMM_ERGODIC
HMM_LEFTRIGHT = _GRT.HMM_LEFTRIGHT
HMM_DISCRETE = _GRT.HMM_DISCRETE
HMM_CONTINUOUS = _GRT.HMM_CONTINUOUS
class ContinuousHiddenMarkovModel(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ContinuousHiddenMarkovModel, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ContinuousHiddenMarkovModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ContinuousHiddenMarkovModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ContinuousHiddenMarkovModel
    __del__ = lambda self: None

    def predict_(self, *args) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_predict_(self, *args)

    def reset(self) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_reset(self)

    def clear(self) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_clear(self)

    def _print(self) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel__print(self)

    def getNumStates(self) -> "UINT":
        return _GRT.ContinuousHiddenMarkovModel_getNumStates(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.ContinuousHiddenMarkovModel_getClassLabel(self)

    def getLoglikelihood(self) -> "GRT::Float":
        return _GRT.ContinuousHiddenMarkovModel_getLoglikelihood(self)

    def getPhase(self) -> "GRT::Float":
        return _GRT.ContinuousHiddenMarkovModel_getPhase(self)

    def getEstimatedStates(self) -> "GRT::Vector< UINT >":
        return _GRT.ContinuousHiddenMarkovModel_getEstimatedStates(self)

    def getAlpha(self) -> "GRT::MatrixFloat":
        return _GRT.ContinuousHiddenMarkovModel_getAlpha(self)

    def setDownsampleFactor(self, downsampleFactor: 'UINT const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setDownsampleFactor(self, downsampleFactor)

    def setModelType(self, modelType: 'UINT const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setModelType(self, modelType)

    def setDelta(self, delta: 'UINT const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setDelta(self, delta)

    def setSigma(self, sigma: 'GRT::Float const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setSigma(self, sigma)

    def setAutoEstimateSigma(self, autoEstimateSigma: 'bool const') -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_setAutoEstimateSigma(self, autoEstimateSigma)

    def save(self, *args) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.ContinuousHiddenMarkovModel_train_(self, *args)
ContinuousHiddenMarkovModel_swigregister = _GRT.ContinuousHiddenMarkovModel_swigregister
ContinuousHiddenMarkovModel_swigregister(ContinuousHiddenMarkovModel)

class HMMTrainingObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMMTrainingObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HMMTrainingObject, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_HMMTrainingObject()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_HMMTrainingObject
    __del__ = lambda self: None
    __swig_setmethods__["alpha"] = _GRT.HMMTrainingObject_alpha_set
    __swig_getmethods__["alpha"] = _GRT.HMMTrainingObject_alpha_get
    if _newclass:
        alpha = _swig_property(_GRT.HMMTrainingObject_alpha_get, _GRT.HMMTrainingObject_alpha_set)
    __swig_setmethods__["beta"] = _GRT.HMMTrainingObject_beta_set
    __swig_getmethods__["beta"] = _GRT.HMMTrainingObject_beta_get
    if _newclass:
        beta = _swig_property(_GRT.HMMTrainingObject_beta_get, _GRT.HMMTrainingObject_beta_set)
    __swig_setmethods__["c"] = _GRT.HMMTrainingObject_c_set
    __swig_getmethods__["c"] = _GRT.HMMTrainingObject_c_get
    if _newclass:
        c = _swig_property(_GRT.HMMTrainingObject_c_get, _GRT.HMMTrainingObject_c_set)
    __swig_setmethods__["pk"] = _GRT.HMMTrainingObject_pk_set
    __swig_getmethods__["pk"] = _GRT.HMMTrainingObject_pk_get
    if _newclass:
        pk = _swig_property(_GRT.HMMTrainingObject_pk_get, _GRT.HMMTrainingObject_pk_set)
HMMTrainingObject_swigregister = _GRT.HMMTrainingObject_swigregister
HMMTrainingObject_swigregister(HMMTrainingObject)

class DiscreteHiddenMarkovModel(MLBase):
    __swig_setmethods__ = {}
    for _s in [MLBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiscreteHiddenMarkovModel, name, value)
    __swig_getmethods__ = {}
    for _s in [MLBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiscreteHiddenMarkovModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_DiscreteHiddenMarkovModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DiscreteHiddenMarkovModel
    __del__ = lambda self: None

    def resetModel(self, numStates: 'UINT const', numSymbols: 'UINT const', modelType: 'UINT const', delta: 'UINT const') -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_resetModel(self, numStates, numSymbols, modelType, delta)

    def reset(self) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_reset(self)

    def randomizeMatrices(self, numStates: 'UINT const', numSymbols: 'UINT const') -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_randomizeMatrices(self, numStates, numSymbols)

    def predictLogLikelihood(self, obs: 'VectorTUINT') -> "GRT::Float":
        return _GRT.DiscreteHiddenMarkovModel_predictLogLikelihood(self, obs)

    def forwardBackward(self, trainingObject: 'HMMTrainingObject', obs: 'VectorTUINT') -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_forwardBackward(self, trainingObject, obs)

    def _print(self) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel__print(self)

    def getTrainingIterationLog(self) -> "GRT::VectorFloat":
        return _GRT.DiscreteHiddenMarkovModel_getTrainingIterationLog(self)

    def save(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_predict_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.DiscreteHiddenMarkovModel_predict(self, *args)
DiscreteHiddenMarkovModel_swigregister = _GRT.DiscreteHiddenMarkovModel_swigregister
DiscreteHiddenMarkovModel_swigregister(DiscreteHiddenMarkovModel)

class HMM(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMM, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_HMM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_HMM
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.HMM_deepCopyFrom(self, classifier)

    def predict_(self, *args) -> "bool":
        return _GRT.HMM_predict_(self, *args)

    def reset(self) -> "bool":
        return _GRT.HMM_reset(self)

    def clear(self) -> "bool":
        return _GRT.HMM_clear(self)

    def _print(self) -> "bool":
        return _GRT.HMM__print(self)

    def getHMMType(self) -> "UINT":
        return _GRT.HMM_getHMMType(self)

    def getModelType(self) -> "UINT":
        return _GRT.HMM_getModelType(self)

    def getDelta(self) -> "UINT":
        return _GRT.HMM_getDelta(self)

    def getNumStates(self) -> "UINT":
        return _GRT.HMM_getNumStates(self)

    def getNumSymbols(self) -> "UINT":
        return _GRT.HMM_getNumSymbols(self)

    def getNumRandomTrainingIterations(self) -> "UINT":
        return _GRT.HMM_getNumRandomTrainingIterations(self)

    def getDiscreteModels(self) -> "GRT::Vector< GRT::DiscreteHiddenMarkovModel >":
        return _GRT.HMM_getDiscreteModels(self)

    def getContinuousModels(self) -> "GRT::Vector< GRT::ContinuousHiddenMarkovModel >":
        return _GRT.HMM_getContinuousModels(self)

    def setHMMType(self, hmmType: 'UINT const') -> "bool":
        return _GRT.HMM_setHMMType(self, hmmType)

    def setModelType(self, modelType: 'UINT const') -> "bool":
        return _GRT.HMM_setModelType(self, modelType)

    def setDelta(self, delta: 'UINT const') -> "bool":
        return _GRT.HMM_setDelta(self, delta)

    def setDownsampleFactor(self, downsampleFactor: 'UINT const') -> "bool":
        return _GRT.HMM_setDownsampleFactor(self, downsampleFactor)

    def setCommitteeSize(self, committeeSize: 'UINT const') -> "bool":
        return _GRT.HMM_setCommitteeSize(self, committeeSize)

    def setNumStates(self, numStates: 'UINT const') -> "bool":
        return _GRT.HMM_setNumStates(self, numStates)

    def setNumSymbols(self, numStates: 'UINT const') -> "bool":
        return _GRT.HMM_setNumSymbols(self, numStates)

    def setNumRandomTrainingIterations(self, numRandomTrainingIterations: 'UINT const') -> "bool":
        return _GRT.HMM_setNumRandomTrainingIterations(self, numRandomTrainingIterations)

    def setSigma(self, sigma: 'GRT::Float const') -> "bool":
        return _GRT.HMM_setSigma(self, sigma)

    def setAutoEstimateSigma(self, autoEstimateSigma: 'bool const') -> "bool":
        return _GRT.HMM_setAutoEstimateSigma(self, autoEstimateSigma)
    if _newclass:
        getId = staticmethod(_GRT.HMM_getId)
    else:
        getId = _GRT.HMM_getId

    def save(self, *args) -> "bool":
        return _GRT.HMM_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.HMM_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.HMM_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.HMM_train_(self, *args)
HMM_swigregister = _GRT.HMM_swigregister
HMM_swigregister(HMM)

def HMM_getId() -> "std::string":
    return _GRT.HMM_getId()
HMM_getId = _GRT.HMM_getId

class MinDistModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinDistModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MinDistModel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MinDistModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MinDistModel
    __del__ = lambda self: None

    def train(self, classLabel: 'UINT', trainingData: 'MatrixFloat', numClusters: 'UINT', minChange: 'GRT::Float', maxNumEpochs: 'UINT') -> "bool":
        return _GRT.MinDistModel_train(self, classLabel, trainingData, numClusters, minChange, maxNumEpochs)

    def predict(self, observation: 'VectorFloat') -> "GRT::Float":
        return _GRT.MinDistModel_predict(self, observation)

    def recomputeThresholdValue(self) -> "void":
        return _GRT.MinDistModel_recomputeThresholdValue(self)

    def getClassLabel(self) -> "UINT":
        return _GRT.MinDistModel_getClassLabel(self)

    def getNumFeatures(self) -> "UINT":
        return _GRT.MinDistModel_getNumFeatures(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.MinDistModel_getNumClusters(self)

    def getRejectionThreshold(self) -> "GRT::Float":
        return _GRT.MinDistModel_getRejectionThreshold(self)

    def getGamma(self) -> "GRT::Float":
        return _GRT.MinDistModel_getGamma(self)

    def getTrainingMu(self) -> "GRT::Float":
        return _GRT.MinDistModel_getTrainingMu(self)

    def getTrainingSigma(self) -> "GRT::Float":
        return _GRT.MinDistModel_getTrainingSigma(self)

    def getClusters(self) -> "GRT::MatrixFloat":
        return _GRT.MinDistModel_getClusters(self)

    def setClassLabel(self, classLabel: 'UINT') -> "bool":
        return _GRT.MinDistModel_setClassLabel(self, classLabel)

    def setClusters(self, clusters: 'MatrixFloat') -> "bool":
        return _GRT.MinDistModel_setClusters(self, clusters)

    def setGamma(self, gamma: 'GRT::Float') -> "bool":
        return _GRT.MinDistModel_setGamma(self, gamma)

    def setRejectionThreshold(self, rejectionThreshold: 'GRT::Float') -> "bool":
        return _GRT.MinDistModel_setRejectionThreshold(self, rejectionThreshold)

    def setTrainingSigma(self, trainingSigma: 'GRT::Float') -> "bool":
        return _GRT.MinDistModel_setTrainingSigma(self, trainingSigma)

    def setTrainingMu(self, trainingMu: 'GRT::Float') -> "bool":
        return _GRT.MinDistModel_setTrainingMu(self, trainingMu)

    def setTrainingLoggingEnabled(self, enabled: 'bool') -> "bool":
        return _GRT.MinDistModel_setTrainingLoggingEnabled(self, enabled)
MinDistModel_swigregister = _GRT.MinDistModel_swigregister
MinDistModel_swigregister(MinDistModel)

class MinDist(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MinDist, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MinDist, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MinDist(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MinDist
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.MinDist_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.MinDist_clear(self)

    def recomputeNullRejectionThresholds(self) -> "bool":
        return _GRT.MinDist_recomputeNullRejectionThresholds(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.MinDist_getNumClusters(self)

    def getModels(self) -> "GRT::Vector< GRT::MinDistModel >":
        return _GRT.MinDist_getModels(self)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float') -> "bool":
        return _GRT.MinDist_setNullRejectionCoeff(self, nullRejectionCoeff)

    def setNumClusters(self, numClusters: 'UINT') -> "bool":
        return _GRT.MinDist_setNumClusters(self, numClusters)
    if _newclass:
        getId = staticmethod(_GRT.MinDist_getId)
    else:
        getId = _GRT.MinDist_getId

    def save(self, *args) -> "bool":
        return _GRT.MinDist_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MinDist_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.MinDist_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.MinDist_predict_(self, *args)
MinDist_swigregister = _GRT.MinDist_swigregister
MinDist_swigregister(MinDist)

def MinDist_getId() -> "std::string":
    return _GRT.MinDist_getId()
MinDist_getId = _GRT.MinDist_getId

class ParticleClassifierGestureTemplate(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleClassifierGestureTemplate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleClassifierGestureTemplate, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_ParticleClassifierGestureTemplate()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ParticleClassifierGestureTemplate
    __del__ = lambda self: None

    def getLength(self) -> "unsigned int":
        return _GRT.ParticleClassifierGestureTemplate_getLength(self)
    __swig_setmethods__["classLabel"] = _GRT.ParticleClassifierGestureTemplate_classLabel_set
    __swig_getmethods__["classLabel"] = _GRT.ParticleClassifierGestureTemplate_classLabel_get
    if _newclass:
        classLabel = _swig_property(_GRT.ParticleClassifierGestureTemplate_classLabel_get, _GRT.ParticleClassifierGestureTemplate_classLabel_set)
    __swig_setmethods__["timeseries"] = _GRT.ParticleClassifierGestureTemplate_timeseries_set
    __swig_getmethods__["timeseries"] = _GRT.ParticleClassifierGestureTemplate_timeseries_get
    if _newclass:
        timeseries = _swig_property(_GRT.ParticleClassifierGestureTemplate_timeseries_get, _GRT.ParticleClassifierGestureTemplate_timeseries_set)
ParticleClassifierGestureTemplate_swigregister = _GRT.ParticleClassifierGestureTemplate_swigregister
ParticleClassifierGestureTemplate_swigregister(ParticleClassifierGestureTemplate)

class ParticleClassifierParticleFilter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleClassifierParticleFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleClassifierParticleFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_ParticleClassifierParticleFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ParticleClassifierParticleFilter
    __del__ = lambda self: None

    def preFilterUpdate(self, data: 'VectorFloat') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_preFilterUpdate(self, data)

    def postFilterUpdate(self, data: 'VectorFloat') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_postFilterUpdate(self, data)

    def predict(self, p: 'Particle') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_predict(self, p)

    def update(self, p: 'Particle', data: 'VectorFloat') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_update(self, p, data)

    def clear(self) -> "bool":
        return _GRT.ParticleClassifierParticleFilter_clear(self)

    def train(self, numParticles: 'unsigned int const', trainingData: 'TimeSeriesClassificationData', sensorNoise: 'GRT::Float', transitionSigma: 'GRT::Float', phaseSigma: 'GRT::Float', velocitySigma: 'GRT::Float') -> "bool":
        return _GRT.ParticleClassifierParticleFilter_train(self, numParticles, trainingData, sensorNoise, transitionSigma, phaseSigma, velocitySigma)
    __swig_setmethods__["numInputDimensions"] = _GRT.ParticleClassifierParticleFilter_numInputDimensions_set
    __swig_getmethods__["numInputDimensions"] = _GRT.ParticleClassifierParticleFilter_numInputDimensions_get
    if _newclass:
        numInputDimensions = _swig_property(_GRT.ParticleClassifierParticleFilter_numInputDimensions_get, _GRT.ParticleClassifierParticleFilter_numInputDimensions_set)
    __swig_setmethods__["numTemplates"] = _GRT.ParticleClassifierParticleFilter_numTemplates_set
    __swig_getmethods__["numTemplates"] = _GRT.ParticleClassifierParticleFilter_numTemplates_get
    if _newclass:
        numTemplates = _swig_property(_GRT.ParticleClassifierParticleFilter_numTemplates_get, _GRT.ParticleClassifierParticleFilter_numTemplates_set)
    __swig_setmethods__["numClasses"] = _GRT.ParticleClassifierParticleFilter_numClasses_set
    __swig_getmethods__["numClasses"] = _GRT.ParticleClassifierParticleFilter_numClasses_get
    if _newclass:
        numClasses = _swig_property(_GRT.ParticleClassifierParticleFilter_numClasses_get, _GRT.ParticleClassifierParticleFilter_numClasses_set)
    __swig_setmethods__["resampleCounter"] = _GRT.ParticleClassifierParticleFilter_resampleCounter_set
    __swig_getmethods__["resampleCounter"] = _GRT.ParticleClassifierParticleFilter_resampleCounter_get
    if _newclass:
        resampleCounter = _swig_property(_GRT.ParticleClassifierParticleFilter_resampleCounter_get, _GRT.ParticleClassifierParticleFilter_resampleCounter_set)
    __swig_setmethods__["gestureTemplates"] = _GRT.ParticleClassifierParticleFilter_gestureTemplates_set
    __swig_getmethods__["gestureTemplates"] = _GRT.ParticleClassifierParticleFilter_gestureTemplates_get
    if _newclass:
        gestureTemplates = _swig_property(_GRT.ParticleClassifierParticleFilter_gestureTemplates_get, _GRT.ParticleClassifierParticleFilter_gestureTemplates_set)
ParticleClassifierParticleFilter_swigregister = _GRT.ParticleClassifierParticleFilter_swigregister
ParticleClassifierParticleFilter_swigregister(ParticleClassifierParticleFilter)

class ParticleClassifier(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParticleClassifier, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ParticleClassifier, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ParticleClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ParticleClassifier
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.ParticleClassifier_deepCopyFrom(self, classifier)

    def save(self, file: 'std::fstream &') -> "bool":
        return _GRT.ParticleClassifier_save(self, file)

    def load(self, file: 'std::fstream &') -> "bool":
        return _GRT.ParticleClassifier_load(self, file)

    def clear(self) -> "bool":
        return _GRT.ParticleClassifier_clear(self)

    def reset(self) -> "bool":
        return _GRT.ParticleClassifier_reset(self)
    if _newclass:
        getId = staticmethod(_GRT.ParticleClassifier_getId)
    else:
        getId = _GRT.ParticleClassifier_getId

    def getGestureTemplates(self) -> "GRT::Vector< GRT::ParticleClassifierGestureTemplate > const &":
        return _GRT.ParticleClassifier_getGestureTemplates(self)

    def getParticleFilter(self) -> "GRT::ParticleClassifierParticleFilter const &":
        return _GRT.ParticleClassifier_getParticleFilter(self)

    def getStateEstimation(self) -> "GRT::VectorFloat":
        return _GRT.ParticleClassifier_getStateEstimation(self)

    def getPhase(self) -> "GRT::Float":
        return _GRT.ParticleClassifier_getPhase(self)

    def getVelocity(self) -> "GRT::Float":
        return _GRT.ParticleClassifier_getVelocity(self)

    def setNumParticles(self, numParticles: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setNumParticles(self, numParticles)

    def setSensorNoise(self, sensorNoise: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setSensorNoise(self, sensorNoise)

    def setTransitionSigma(self, transitionSigma: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setTransitionSigma(self, transitionSigma)

    def setPhaseSigma(self, phaseSigma: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setPhaseSigma(self, phaseSigma)

    def setVelocitySigma(self, velocitySigma: 'unsigned int const') -> "bool":
        return _GRT.ParticleClassifier_setVelocitySigma(self, velocitySigma)

    def predict_(self, *args) -> "bool":
        return _GRT.ParticleClassifier_predict_(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.ParticleClassifier_train_(self, *args)
ParticleClassifier_swigregister = _GRT.ParticleClassifier_swigregister
ParticleClassifier_swigregister(ParticleClassifier)

def ParticleClassifier_getId() -> "std::string":
    return _GRT.ParticleClassifier_getId()
ParticleClassifier_getId = _GRT.ParticleClassifier_getId

class RandomForests(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RandomForests, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RandomForests, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_RandomForests(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_RandomForests
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.RandomForests_deepCopyFrom(self, classifier)

    def train_(self, trainingData: 'ClassificationData') -> "bool":
        return _GRT.RandomForests_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.RandomForests_predict_(self, inputVector)

    def clear(self) -> "bool":
        return _GRT.RandomForests_clear(self)

    def _print(self) -> "bool":
        return _GRT.RandomForests__print(self)

    def combineModels(self, forest: 'RandomForests') -> "bool":
        return _GRT.RandomForests_combineModels(self, forest)

    def getForestSize(self) -> "UINT":
        return _GRT.RandomForests_getForestSize(self)

    def getNumRandomSplits(self) -> "UINT":
        return _GRT.RandomForests_getNumRandomSplits(self)

    def getMinNumSamplesPerNode(self) -> "UINT":
        return _GRT.RandomForests_getMinNumSamplesPerNode(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.RandomForests_getMaxDepth(self)

    def getTrainingMode(self) -> "UINT":
        return _GRT.RandomForests_getTrainingMode(self)

    def getForest(self) -> "GRT::Vector< GRT::DecisionTreeNode * > const &":
        return _GRT.RandomForests_getForest(self)

    def getRemoveFeaturesAtEachSplit(self) -> "bool":
        return _GRT.RandomForests_getRemoveFeaturesAtEachSplit(self)

    def getBootstrappedDatasetWeight(self) -> "GRT::Float":
        return _GRT.RandomForests_getBootstrappedDatasetWeight(self)

    def getTree(self, index: 'UINT const') -> "GRT::DecisionTreeNode *":
        return _GRT.RandomForests_getTree(self, index)

    def deepCopyDecisionTreeNode(self) -> "GRT::DecisionTreeNode *":
        return _GRT.RandomForests_deepCopyDecisionTreeNode(self)

    def getFeatureWeights(self, normWeights: 'bool const'=True) -> "GRT::VectorDouble":
        return _GRT.RandomForests_getFeatureWeights(self, normWeights)

    def getLeafNodeFeatureWeights(self, normWeights: 'bool const'=True) -> "GRT::MatrixDouble":
        return _GRT.RandomForests_getLeafNodeFeatureWeights(self, normWeights)

    def setForestSize(self, forestSize: 'UINT const') -> "bool":
        return _GRT.RandomForests_setForestSize(self, forestSize)

    def setNumRandomSplits(self, numSplittingSteps: 'UINT const') -> "bool":
        return _GRT.RandomForests_setNumRandomSplits(self, numSplittingSteps)

    def setMinNumSamplesPerNode(self, minNumSamplesPerNode: 'UINT const') -> "bool":
        return _GRT.RandomForests_setMinNumSamplesPerNode(self, minNumSamplesPerNode)

    def setMaxDepth(self, maxDepth: 'UINT const') -> "bool":
        return _GRT.RandomForests_setMaxDepth(self, maxDepth)

    def setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit: 'bool const') -> "bool":
        return _GRT.RandomForests_setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit)

    def setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt: 'bool const') -> "bool":
        return _GRT.RandomForests_setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt)

    def setTrainingMode(self, trainingMode: 'GRT::Tree::TrainingMode const') -> "bool":
        return _GRT.RandomForests_setTrainingMode(self, trainingMode)

    def setDecisionTreeNode(self, node: 'DecisionTreeNode') -> "bool":
        return _GRT.RandomForests_setDecisionTreeNode(self, node)

    def setBootstrappedDatasetWeight(self, bootstrappedDatasetWeight: 'GRT::Float const') -> "bool":
        return _GRT.RandomForests_setBootstrappedDatasetWeight(self, bootstrappedDatasetWeight)
    if _newclass:
        getId = staticmethod(_GRT.RandomForests_getId)
    else:
        getId = _GRT.RandomForests_getId

    def save(self, *args) -> "bool":
        return _GRT.RandomForests_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.RandomForests_load(self, *args)
RandomForests_swigregister = _GRT.RandomForests_swigregister
RandomForests_swigregister(RandomForests)

def RandomForests_getId() -> "std::string":
    return _GRT.RandomForests_getId()
RandomForests_getId = _GRT.RandomForests_getId

class SoftmaxModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SoftmaxModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SoftmaxModel, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_SoftmaxModel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SoftmaxModel
    __del__ = lambda self: None

    def init(self, classLabel: 'UINT', N: 'UINT') -> "bool":
        return _GRT.SoftmaxModel_init(self, classLabel, N)

    def compute(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.SoftmaxModel_compute(self, x)
    __swig_setmethods__["classLabel"] = _GRT.SoftmaxModel_classLabel_set
    __swig_getmethods__["classLabel"] = _GRT.SoftmaxModel_classLabel_get
    if _newclass:
        classLabel = _swig_property(_GRT.SoftmaxModel_classLabel_get, _GRT.SoftmaxModel_classLabel_set)
    __swig_setmethods__["N"] = _GRT.SoftmaxModel_N_set
    __swig_getmethods__["N"] = _GRT.SoftmaxModel_N_get
    if _newclass:
        N = _swig_property(_GRT.SoftmaxModel_N_get, _GRT.SoftmaxModel_N_set)
    __swig_setmethods__["w"] = _GRT.SoftmaxModel_w_set
    __swig_getmethods__["w"] = _GRT.SoftmaxModel_w_get
    if _newclass:
        w = _swig_property(_GRT.SoftmaxModel_w_get, _GRT.SoftmaxModel_w_set)
    __swig_setmethods__["w0"] = _GRT.SoftmaxModel_w0_set
    __swig_getmethods__["w0"] = _GRT.SoftmaxModel_w0_get
    if _newclass:
        w0 = _swig_property(_GRT.SoftmaxModel_w0_get, _GRT.SoftmaxModel_w0_set)
SoftmaxModel_swigregister = _GRT.SoftmaxModel_swigregister
SoftmaxModel_swigregister(SoftmaxModel)

class Softmax(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Softmax, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Softmax, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_Softmax(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Softmax
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.Softmax_deepCopyFrom(self, classifier)

    def train_(self, trainingData: 'ClassificationData') -> "bool":
        return _GRT.Softmax_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.Softmax_predict_(self, inputVector)

    def clear(self) -> "bool":
        return _GRT.Softmax_clear(self)

    def getModels(self) -> "GRT::Vector< GRT::SoftmaxModel >":
        return _GRT.Softmax_getModels(self)
    if _newclass:
        getId = staticmethod(_GRT.Softmax_getId)
    else:
        getId = _GRT.Softmax_getId

    def save(self, *args) -> "bool":
        return _GRT.Softmax_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.Softmax_load(self, *args)
Softmax_swigregister = _GRT.Softmax_swigregister
Softmax_swigregister(Softmax)

def Softmax_getId() -> "std::string":
    return _GRT.Softmax_getId()
Softmax_getId = _GRT.Softmax_getId

SVM_MIN_SCALE_RANGE = _GRT.SVM_MIN_SCALE_RANGE
SVM_MAX_SCALE_RANGE = _GRT.SVM_MAX_SCALE_RANGE
class SVM(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVM, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SVM, name)
    __repr__ = _swig_repr
    C_SVC = _GRT.SVM_C_SVC
    NU_SVC = _GRT.SVM_NU_SVC
    ONE_CLASS = _GRT.SVM_ONE_CLASS
    EPSILON_SVR = _GRT.SVM_EPSILON_SVR
    NU_SVR = _GRT.SVM_NU_SVR
    NUM_SVM_TYPES = _GRT.SVM_NUM_SVM_TYPES
    LINEAR_KERNEL = _GRT.SVM_LINEAR_KERNEL
    POLY_KERNEL = _GRT.SVM_POLY_KERNEL
    RBF_KERNEL = _GRT.SVM_RBF_KERNEL
    SIGMOID_KERNEL = _GRT.SVM_SIGMOID_KERNEL
    PRECOMPUTED_KERNEL = _GRT.SVM_PRECOMPUTED_KERNEL
    NUM_KERNEL_TYPES = _GRT.SVM_NUM_KERNEL_TYPES

    def __init__(self, *args):
        this = _GRT.new_SVM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SVM
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.SVM_deepCopyFrom(self, classifier)

    def clear(self) -> "bool":
        return _GRT.SVM_clear(self)

    def init(self, kernelType: 'GRT::SVM::KernelType', svmType: 'GRT::SVM::SVMType', useScaling: 'bool', useNullRejection: 'bool', useAutoGamma: 'bool', gamma: 'GRT::Float', degree: 'UINT', coef0: 'GRT::Float', nu: 'GRT::Float', C: 'GRT::Float', useCrossValidation: 'bool', kFoldValue: 'UINT') -> "bool":
        return _GRT.SVM_init(self, kernelType, svmType, useScaling, useNullRejection, useAutoGamma, gamma, degree, coef0, nu, C, useCrossValidation, kFoldValue)

    def initDefaultSVMSettings(self) -> "void":
        return _GRT.SVM_initDefaultSVMSettings(self)

    def getIsCrossValidationTrainingEnabled(self) -> "bool":
        return _GRT.SVM_getIsCrossValidationTrainingEnabled(self)

    def getIsAutoGammaEnabled(self) -> "bool":
        return _GRT.SVM_getIsAutoGammaEnabled(self)

    def getSVMType(self) -> "std::string":
        return _GRT.SVM_getSVMType(self)

    def getKernelType(self) -> "std::string":
        return _GRT.SVM_getKernelType(self)

    def getDegree(self) -> "UINT":
        return _GRT.SVM_getDegree(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.SVM_getNumClasses(self)

    def getGamma(self) -> "GRT::Float":
        return _GRT.SVM_getGamma(self)

    def getNu(self) -> "GRT::Float":
        return _GRT.SVM_getNu(self)

    def getCoef0(self) -> "GRT::Float":
        return _GRT.SVM_getCoef0(self)

    def getC(self) -> "GRT::Float":
        return _GRT.SVM_getC(self)

    def getCrossValidationResult(self) -> "GRT::Float":
        return _GRT.SVM_getCrossValidationResult(self)

    def getLIBSVMModel(self) -> "LIBSVM::svm_model const *":
        return _GRT.SVM_getLIBSVMModel(self)

    def setSVMType(self, svmType: 'GRT::SVM::SVMType const') -> "bool":
        return _GRT.SVM_setSVMType(self, svmType)

    def setKernelType(self, kernelType: 'GRT::SVM::KernelType const') -> "bool":
        return _GRT.SVM_setKernelType(self, kernelType)

    def setGamma(self, gamma: 'GRT::Float const') -> "bool":
        return _GRT.SVM_setGamma(self, gamma)

    def setDegree(self, degree: 'UINT const') -> "bool":
        return _GRT.SVM_setDegree(self, degree)

    def setNu(self, nu: 'GRT::Float const') -> "bool":
        return _GRT.SVM_setNu(self, nu)

    def setCoef0(self, coef0: 'GRT::Float const') -> "bool":
        return _GRT.SVM_setCoef0(self, coef0)

    def setC(self, C: 'GRT::Float const') -> "bool":
        return _GRT.SVM_setC(self, C)

    def setKFoldCrossValidationValue(self, kFoldValue: 'UINT const') -> "bool":
        return _GRT.SVM_setKFoldCrossValidationValue(self, kFoldValue)

    def enableAutoGamma(self, useAutoGamma: 'bool const') -> "bool":
        return _GRT.SVM_enableAutoGamma(self, useAutoGamma)

    def enableCrossValidationTraining(self, useCrossValidation: 'bool const') -> "bool":
        return _GRT.SVM_enableCrossValidationTraining(self, useCrossValidation)
    if _newclass:
        getId = staticmethod(_GRT.SVM_getId)
    else:
        getId = _GRT.SVM_getId

    def save(self, *args) -> "bool":
        return _GRT.SVM_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.SVM_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.SVM_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.SVM_predict_(self, *args)
SVM_swigregister = _GRT.SVM_swigregister
SVM_swigregister(SVM)

def SVM_getId() -> "std::string":
    return _GRT.SVM_getId()
SVM_getId = _GRT.SVM_getId

class SwipeDetector(Classifier):
    __swig_setmethods__ = {}
    for _s in [Classifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwipeDetector, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SwipeDetector, name)
    __repr__ = _swig_repr
    POSITIVE_SWIPE = _GRT.SwipeDetector_POSITIVE_SWIPE
    NEGATIVE_SWIPE = _GRT.SwipeDetector_NEGATIVE_SWIPE

    def __init__(self, *args):
        this = _GRT.new_SwipeDetector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SwipeDetector
    __del__ = lambda self: None

    def deepCopyFrom(self, classifier: 'Classifier') -> "bool":
        return _GRT.SwipeDetector_deepCopyFrom(self, classifier)

    def init(self, numInputDimensions: 'unsigned int const') -> "bool":
        return _GRT.SwipeDetector_init(self, numInputDimensions)

    def clear(self) -> "bool":
        return _GRT.SwipeDetector_clear(self)

    def reset(self) -> "bool":
        return _GRT.SwipeDetector_reset(self)

    def getSwipeDetected(self) -> "bool":
        return _GRT.SwipeDetector_getSwipeDetected(self)

    def getSwipeValue(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getSwipeValue(self)

    def getSwipeThreshold(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getSwipeThreshold(self)

    def getHysteresisThreshold(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getHysteresisThreshold(self)

    def getMovementVelocity(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getMovementVelocity(self)

    def getMovementThreshold(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getMovementThreshold(self)

    def getContextValue(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getContextValue(self)

    def getSwipeIntegrationCoeff(self) -> "GRT::Float":
        return _GRT.SwipeDetector_getSwipeIntegrationCoeff(self)

    def setContext(self, context: 'bool const') -> "bool":
        return _GRT.SwipeDetector_setContext(self, context)

    def setSwipeIndex(self, swipeIndex: 'unsigned int const') -> "bool":
        return _GRT.SwipeDetector_setSwipeIndex(self, swipeIndex)

    def setSwipeDirection(self, swipeDirection: 'unsigned int const') -> "bool":
        return _GRT.SwipeDetector_setSwipeDirection(self, swipeDirection)

    def setSwipeThreshold(self, swipeThreshold: 'GRT::Float const') -> "bool":
        return _GRT.SwipeDetector_setSwipeThreshold(self, swipeThreshold)

    def setHysteresisThreshold(self, hysteresisThreshold: 'GRT::Float const') -> "bool":
        return _GRT.SwipeDetector_setHysteresisThreshold(self, hysteresisThreshold)

    def setMovementThreshold(self, movementThreshold: 'GRT::Float const') -> "bool":
        return _GRT.SwipeDetector_setMovementThreshold(self, movementThreshold)

    def setSwipeIntegrationCoeff(self, swipeIntegrationCoeff: 'GRT::Float const') -> "bool":
        return _GRT.SwipeDetector_setSwipeIntegrationCoeff(self, swipeIntegrationCoeff)
    if _newclass:
        getId = staticmethod(_GRT.SwipeDetector_getId)
    else:
        getId = _GRT.SwipeDetector_getId

    def save(self, *args) -> "bool":
        return _GRT.SwipeDetector_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.SwipeDetector_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.SwipeDetector_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.SwipeDetector_predict_(self, *args)
SwipeDetector_swigregister = _GRT.SwipeDetector_swigregister
SwipeDetector_swigregister(SwipeDetector)

def SwipeDetector_getId() -> "std::string":
    return _GRT.SwipeDetector_getId()
SwipeDetector_getId = _GRT.SwipeDetector_getId

class ClusterTreeNode(Node):
    __swig_setmethods__ = {}
    for _s in [Node]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterTreeNode, name, value)
    __swig_getmethods__ = {}
    for _s in [Node]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterTreeNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_ClusterTreeNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClusterTreeNode
    __del__ = lambda self: None

    def predict_(self, *args) -> "bool":
        return _GRT.ClusterTreeNode_predict_(self, *args)

    def clear(self) -> "bool":
        return _GRT.ClusterTreeNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.ClusterTreeNode__print(self)

    def deepCopy(self) -> "GRT::Node *":
        return _GRT.ClusterTreeNode_deepCopy(self)

    def deepCopyTree(self) -> "GRT::ClusterTreeNode *":
        return _GRT.ClusterTreeNode_deepCopyTree(self)

    def getNodeSize(self) -> "UINT":
        return _GRT.ClusterTreeNode_getNodeSize(self)

    def getFeatureIndex(self) -> "UINT":
        return _GRT.ClusterTreeNode_getFeatureIndex(self)

    def getThreshold(self) -> "GRT::Float":
        return _GRT.ClusterTreeNode_getThreshold(self)

    def getClusterLabel(self) -> "UINT":
        return _GRT.ClusterTreeNode_getClusterLabel(self)

    def set(self, nodeSize: 'UINT const', featureIndex: 'UINT const', threshold: 'GRT::Float const', clusterLabel: 'UINT const') -> "bool":
        return _GRT.ClusterTreeNode_set(self, nodeSize, featureIndex, threshold, clusterLabel)
ClusterTreeNode_swigregister = _GRT.ClusterTreeNode_swigregister
ClusterTreeNode_swigregister(ClusterTreeNode)

class ClusterTree(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterTree, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterTree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClusterTree(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClusterTree
    __del__ = lambda self: None

    def deepCopyFrom(self, cluster: 'Clusterer') -> "bool":
        return _GRT.ClusterTree_deepCopyFrom(self, cluster)

    def train_(self, trainingData: 'MatrixFloat') -> "bool":
        return _GRT.ClusterTree_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.ClusterTree_predict_(self, inputVector)

    def clear(self) -> "bool":
        return _GRT.ClusterTree_clear(self)

    def _print(self) -> "bool":
        return _GRT.ClusterTree__print(self)

    def deepCopyTree(self) -> "GRT::ClusterTreeNode *":
        return _GRT.ClusterTree_deepCopyTree(self)

    def getTree(self) -> "GRT::ClusterTreeNode const *":
        return _GRT.ClusterTree_getTree(self)

    def getPredictedClusterLabel(self) -> "UINT":
        return _GRT.ClusterTree_getPredictedClusterLabel(self)

    def getMinRMSErrorPerNode(self) -> "GRT::Float":
        return _GRT.ClusterTree_getMinRMSErrorPerNode(self)

    def getTrainingMode(self) -> "GRT::Tree::TrainingMode":
        return _GRT.ClusterTree_getTrainingMode(self)

    def getNumSplittingSteps(self) -> "UINT":
        return _GRT.ClusterTree_getNumSplittingSteps(self)

    def getMinNumSamplesPerNode(self) -> "UINT":
        return _GRT.ClusterTree_getMinNumSamplesPerNode(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.ClusterTree_getMaxDepth(self)

    def getPredictedNodeID(self) -> "UINT":
        return _GRT.ClusterTree_getPredictedNodeID(self)

    def getRemoveFeaturesAtEachSplit(self) -> "bool":
        return _GRT.ClusterTree_getRemoveFeaturesAtEachSplit(self)

    def setTrainingMode(self, trainingMode: 'GRT::Tree::TrainingMode const') -> "bool":
        return _GRT.ClusterTree_setTrainingMode(self, trainingMode)

    def setNumSplittingSteps(self, numSplittingSteps: 'UINT const') -> "bool":
        return _GRT.ClusterTree_setNumSplittingSteps(self, numSplittingSteps)

    def setMinNumSamplesPerNode(self, minNumSamplesPerNode: 'UINT const') -> "bool":
        return _GRT.ClusterTree_setMinNumSamplesPerNode(self, minNumSamplesPerNode)

    def setMaxDepth(self, maxDepth: 'UINT const') -> "bool":
        return _GRT.ClusterTree_setMaxDepth(self, maxDepth)

    def setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit: 'bool const') -> "bool":
        return _GRT.ClusterTree_setRemoveFeaturesAtEachSplit(self, removeFeaturesAtEachSplit)

    def setMinRMSErrorPerNode(self, minRMSErrorPerNode: 'GRT::Float const') -> "bool":
        return _GRT.ClusterTree_setMinRMSErrorPerNode(self, minRMSErrorPerNode)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.ClusterTree_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.ClusterTree_loadModelFromFile(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.ClusterTree_train(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.ClusterTree_predict(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.ClusterTree_getId)
    else:
        getId = _GRT.ClusterTree_getId
ClusterTree_swigregister = _GRT.ClusterTree_swigregister
ClusterTree_swigregister(ClusterTree)

def ClusterTree_getId() -> "std::string":
    return _GRT.ClusterTree_getId()
ClusterTree_getId = _GRT.ClusterTree_getId

class GaussianMixtureModels(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianMixtureModels, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianMixtureModels, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_GaussianMixtureModels(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GaussianMixtureModels
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.GaussianMixtureModels_deepCopyFrom(self, clusterer)

    def reset(self) -> "bool":
        return _GRT.GaussianMixtureModels_reset(self)

    def clear(self) -> "bool":
        return _GRT.GaussianMixtureModels_clear(self)

    def train_(self, *args) -> "bool":
        return _GRT.GaussianMixtureModels_train_(self, *args)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.GaussianMixtureModels_predict_(self, inputVector)

    def getMu(self) -> "GRT::MatrixFloat":
        return _GRT.GaussianMixtureModels_getMu(self)

    def getSigma(self, *args) -> "GRT::MatrixFloat":
        return _GRT.GaussianMixtureModels_getSigma(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.GaussianMixtureModels_getId)
    else:
        getId = _GRT.GaussianMixtureModels_getId

    def setNumRestarts(self, numRestarts: 'UINT const') -> "bool":
        return _GRT.GaussianMixtureModels_setNumRestarts(self, numRestarts)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.GaussianMixtureModels_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.GaussianMixtureModels_loadModelFromFile(self, *args)
GaussianMixtureModels_swigregister = _GRT.GaussianMixtureModels_swigregister
GaussianMixtureModels_swigregister(GaussianMixtureModels)

def GaussianMixtureModels_getId() -> "std::string":
    return _GRT.GaussianMixtureModels_getId()
GaussianMixtureModels_getId = _GRT.GaussianMixtureModels_getId

class ClusterInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterInfo, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClusterInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClusterInfo
    __del__ = lambda self: None

    def addSampleToCluster(self, i: 'UINT') -> "void":
        return _GRT.ClusterInfo_addSampleToCluster(self, i)

    def getUniqueClusterID(self) -> "UINT":
        return _GRT.ClusterInfo_getUniqueClusterID(self)

    def getNumSamplesInCluster(self) -> "UINT":
        return _GRT.ClusterInfo_getNumSamplesInCluster(self)

    def getClusterVariance(self) -> "GRT::Float":
        return _GRT.ClusterInfo_getClusterVariance(self)
    __swig_setmethods__["uniqueClusterID"] = _GRT.ClusterInfo_uniqueClusterID_set
    __swig_getmethods__["uniqueClusterID"] = _GRT.ClusterInfo_uniqueClusterID_get
    if _newclass:
        uniqueClusterID = _swig_property(_GRT.ClusterInfo_uniqueClusterID_get, _GRT.ClusterInfo_uniqueClusterID_set)
    __swig_setmethods__["clusterVariance"] = _GRT.ClusterInfo_clusterVariance_set
    __swig_getmethods__["clusterVariance"] = _GRT.ClusterInfo_clusterVariance_get
    if _newclass:
        clusterVariance = _swig_property(_GRT.ClusterInfo_clusterVariance_get, _GRT.ClusterInfo_clusterVariance_set)
    __swig_setmethods__["indexs"] = _GRT.ClusterInfo_indexs_set
    __swig_getmethods__["indexs"] = _GRT.ClusterInfo_indexs_get
    if _newclass:
        indexs = _swig_property(_GRT.ClusterInfo_indexs_get, _GRT.ClusterInfo_indexs_set)
ClusterInfo_swigregister = _GRT.ClusterInfo_swigregister
ClusterInfo_swigregister(ClusterInfo)

class ClusterLevel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClusterLevel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClusterLevel, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClusterLevel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClusterLevel
    __del__ = lambda self: None

    def getLevel(self) -> "UINT":
        return _GRT.ClusterLevel_getLevel(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.ClusterLevel_getNumClusters(self)
    __swig_setmethods__["level"] = _GRT.ClusterLevel_level_set
    __swig_getmethods__["level"] = _GRT.ClusterLevel_level_get
    if _newclass:
        level = _swig_property(_GRT.ClusterLevel_level_get, _GRT.ClusterLevel_level_set)
    __swig_setmethods__["clusters"] = _GRT.ClusterLevel_clusters_set
    __swig_getmethods__["clusters"] = _GRT.ClusterLevel_clusters_get
    if _newclass:
        clusters = _swig_property(_GRT.ClusterLevel_clusters_get, _GRT.ClusterLevel_clusters_set)
ClusterLevel_swigregister = _GRT.ClusterLevel_swigregister
ClusterLevel_swigregister(ClusterLevel)

class HierarchicalClustering(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HierarchicalClustering, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HierarchicalClustering, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_HierarchicalClustering(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_HierarchicalClustering
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.HierarchicalClustering_deepCopyFrom(self, clusterer)

    def reset(self) -> "bool":
        return _GRT.HierarchicalClustering_reset(self)

    def clear(self) -> "bool":
        return _GRT.HierarchicalClustering_clear(self)

    def train_(self, *args) -> "bool":
        return _GRT.HierarchicalClustering_train_(self, *args)

    def printModel(self) -> "bool":
        return _GRT.HierarchicalClustering_printModel(self)

    def getClusters(self) -> "GRT::Vector< GRT::ClusterLevel >":
        return _GRT.HierarchicalClustering_getClusters(self)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.HierarchicalClustering_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.HierarchicalClustering_loadModelFromFile(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.HierarchicalClustering_getId)
    else:
        getId = _GRT.HierarchicalClustering_getId
HierarchicalClustering_swigregister = _GRT.HierarchicalClustering_swigregister
HierarchicalClustering_swigregister(HierarchicalClustering)

def HierarchicalClustering_getId() -> "std::string":
    return _GRT.HierarchicalClustering_getId()
HierarchicalClustering_getId = _GRT.HierarchicalClustering_getId

class KMeans(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeans, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeans, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_KMeans(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_KMeans
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.KMeans_deepCopyFrom(self, clusterer)

    def reset(self) -> "bool":
        return _GRT.KMeans_reset(self)

    def clear(self) -> "bool":
        return _GRT.KMeans_clear(self)

    def trainModel(self, data: 'MatrixFloat') -> "bool":
        return _GRT.KMeans_trainModel(self, data)

    def getTheta(self) -> "GRT::Float":
        return _GRT.KMeans_getTheta(self)

    def getModelTrained(self) -> "bool":
        return _GRT.KMeans_getModelTrained(self)

    def getTrainingThetaLog(self) -> "GRT::VectorFloat const &":
        return _GRT.KMeans_getTrainingThetaLog(self)

    def getClusters(self) -> "GRT::MatrixFloat const &":
        return _GRT.KMeans_getClusters(self)

    def getClassLabelsVector(self) -> "GRT::Vector< UINT > const &":
        return _GRT.KMeans_getClassLabelsVector(self)

    def getClassCountVector(self) -> "GRT::Vector< UINT > const &":
        return _GRT.KMeans_getClassCountVector(self)

    def setComputeTheta(self, computeTheta: 'bool const') -> "bool":
        return _GRT.KMeans_setComputeTheta(self, computeTheta)

    def setClusters(self, clusters: 'MatrixFloat') -> "bool":
        return _GRT.KMeans_setClusters(self, clusters)

    def saveModelToFile(self, *args) -> "bool":
        return _GRT.KMeans_saveModelToFile(self, *args)

    def loadModelFromFile(self, *args) -> "bool":
        return _GRT.KMeans_loadModelFromFile(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.KMeans_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.KMeans_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.KMeans_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.KMeans_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.KMeans_getId)
    else:
        getId = _GRT.KMeans_getId
KMeans_swigregister = _GRT.KMeans_swigregister
KMeans_swigregister(KMeans)

def KMeans_getId() -> "std::string":
    return _GRT.KMeans_getId()
KMeans_getId = _GRT.KMeans_getId

class GaussNeuron(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussNeuron, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GaussNeuron, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_GaussNeuron()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GaussNeuron
    __del__ = lambda self: None

    def init(self, numInputs: 'UINT const', sigma: 'GRT::Float const'=2.0, minWeightRange: 'GRT::Float const'=-1.0, maxWeightRange: 'GRT::Float const'=1.0) -> "bool":
        return _GRT.GaussNeuron_init(self, numInputs, sigma, minWeightRange, maxWeightRange)

    def clear(self) -> "bool":
        return _GRT.GaussNeuron_clear(self)

    def getInitialized(self) -> "bool":
        return _GRT.GaussNeuron_getInitialized(self)

    def getWeightDistance(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.GaussNeuron_getWeightDistance(self, x)

    def getSquaredWeightDistance(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.GaussNeuron_getSquaredWeightDistance(self, x)

    def fire(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.GaussNeuron_fire(self, x)

    def save(self, file: 'std::fstream &') -> "bool":
        return _GRT.GaussNeuron_save(self, file)

    def load(self, file: 'std::fstream &') -> "bool":
        return _GRT.GaussNeuron_load(self, file)
    __swig_setmethods__["numInputs"] = _GRT.GaussNeuron_numInputs_set
    __swig_getmethods__["numInputs"] = _GRT.GaussNeuron_numInputs_get
    if _newclass:
        numInputs = _swig_property(_GRT.GaussNeuron_numInputs_get, _GRT.GaussNeuron_numInputs_set)
    __swig_setmethods__["weights"] = _GRT.GaussNeuron_weights_set
    __swig_getmethods__["weights"] = _GRT.GaussNeuron_weights_get
    if _newclass:
        weights = _swig_property(_GRT.GaussNeuron_weights_get, _GRT.GaussNeuron_weights_set)
    __swig_setmethods__["sigma"] = _GRT.GaussNeuron_sigma_set
    __swig_getmethods__["sigma"] = _GRT.GaussNeuron_sigma_get
    if _newclass:
        sigma = _swig_property(_GRT.GaussNeuron_sigma_get, _GRT.GaussNeuron_sigma_set)
    __swig_setmethods__["initialized"] = _GRT.GaussNeuron_initialized_set
    __swig_getmethods__["initialized"] = _GRT.GaussNeuron_initialized_get
    if _newclass:
        initialized = _swig_property(_GRT.GaussNeuron_initialized_get, _GRT.GaussNeuron_initialized_set)
GaussNeuron_swigregister = _GRT.GaussNeuron_swigregister
GaussNeuron_swigregister(GaussNeuron)

class SelfOrganizingMap(Clusterer):
    __swig_setmethods__ = {}
    for _s in [Clusterer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SelfOrganizingMap, name, value)
    __swig_getmethods__ = {}
    for _s in [Clusterer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SelfOrganizingMap, name)
    __repr__ = _swig_repr
    RANDOM_NETWORK = _GRT.SelfOrganizingMap_RANDOM_NETWORK

    def __init__(self, *args):
        this = _GRT.new_SelfOrganizingMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SelfOrganizingMap
    __del__ = lambda self: None

    def deepCopyFrom(self, clusterer: 'Clusterer') -> "bool":
        return _GRT.SelfOrganizingMap_deepCopyFrom(self, clusterer)

    def reset(self) -> "bool":
        return _GRT.SelfOrganizingMap_reset(self)

    def clear(self) -> "bool":
        return _GRT.SelfOrganizingMap_clear(self)

    def train_(self, *args) -> "bool":
        return _GRT.SelfOrganizingMap_train_(self, *args)

    def map_(self, x: 'VectorFloat') -> "bool":
        return _GRT.SelfOrganizingMap_map_(self, x)

    def validateNetworkTypology(self, networkTypology: 'UINT const') -> "bool":
        return _GRT.SelfOrganizingMap_validateNetworkTypology(self, networkTypology)

    def getNetworkSize(self) -> "UINT":
        return _GRT.SelfOrganizingMap_getNetworkSize(self)

    def getAlphaStart(self) -> "GRT::Float":
        return _GRT.SelfOrganizingMap_getAlphaStart(self)

    def getAlphaEnd(self) -> "GRT::Float":
        return _GRT.SelfOrganizingMap_getAlphaEnd(self)

    def getMappedData(self) -> "GRT::VectorFloat":
        return _GRT.SelfOrganizingMap_getMappedData(self)

    def getNeurons(self) -> "GRT::Matrix< GRT::GaussNeuron >":
        return _GRT.SelfOrganizingMap_getNeurons(self)

    def getNeuronsRef(self) -> "GRT::Matrix< GRT::GaussNeuron > const &":
        return _GRT.SelfOrganizingMap_getNeuronsRef(self)

    def getWeightsMatrix(self) -> "GRT::Matrix< GRT::VectorFloat >":
        return _GRT.SelfOrganizingMap_getWeightsMatrix(self)

    def setNetworkSize(self, networkSize: 'UINT const') -> "bool":
        return _GRT.SelfOrganizingMap_setNetworkSize(self, networkSize)

    def setNetworkTypology(self, networkTypology: 'UINT const') -> "bool":
        return _GRT.SelfOrganizingMap_setNetworkTypology(self, networkTypology)

    def setAlphaStart(self, alphaStart: 'GRT::Float const') -> "bool":
        return _GRT.SelfOrganizingMap_setAlphaStart(self, alphaStart)

    def setAlphaEnd(self, alphaEnd: 'GRT::Float const') -> "bool":
        return _GRT.SelfOrganizingMap_setAlphaEnd(self, alphaEnd)

    def setSigmaWeight(self, sigmaWeight: 'GRT::Float const') -> "bool":
        return _GRT.SelfOrganizingMap_setSigmaWeight(self, sigmaWeight)

    def save(self, *args) -> "bool":
        return _GRT.SelfOrganizingMap_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.SelfOrganizingMap_load(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.SelfOrganizingMap_getId)
    else:
        getId = _GRT.SelfOrganizingMap_getId
SelfOrganizingMap_swigregister = _GRT.SelfOrganizingMap_swigregister
SelfOrganizingMap_swigregister(SelfOrganizingMap)

def SelfOrganizingMap_getId() -> "std::string":
    return _GRT.SelfOrganizingMap_getId()
SelfOrganizingMap_getId = _GRT.SelfOrganizingMap_getId

class KMeansQuantizer(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeansQuantizer, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeansQuantizer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_KMeansQuantizer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_KMeansQuantizer
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.KMeansQuantizer_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.KMeansQuantizer_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.KMeansQuantizer_reset(self)

    def clear(self) -> "bool":
        return _GRT.KMeansQuantizer_clear(self)

    def quantize(self, *args) -> "UINT":
        return _GRT.KMeansQuantizer_quantize(self, *args)

    def getQuantizerTrained(self) -> "bool":
        return _GRT.KMeansQuantizer_getQuantizerTrained(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.KMeansQuantizer_getNumClusters(self)

    def getQuantizedValue(self) -> "UINT":
        return _GRT.KMeansQuantizer_getQuantizedValue(self)

    def getQuantizationDistances(self) -> "GRT::VectorFloat":
        return _GRT.KMeansQuantizer_getQuantizationDistances(self)

    def getQuantizationModel(self) -> "GRT::MatrixFloat":
        return _GRT.KMeansQuantizer_getQuantizationModel(self)

    def setNumClusters(self, numClusters: 'UINT const') -> "bool":
        return _GRT.KMeansQuantizer_setNumClusters(self, numClusters)

    def save(self, *args) -> "bool":
        return _GRT.KMeansQuantizer_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.KMeansQuantizer_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.KMeansQuantizer_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.KMeansQuantizer_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.KMeansQuantizer_getId)
    else:
        getId = _GRT.KMeansQuantizer_getId
KMeansQuantizer_swigregister = _GRT.KMeansQuantizer_swigregister
KMeansQuantizer_swigregister(KMeansQuantizer)

def KMeansQuantizer_getId() -> "std::string":
    return _GRT.KMeansQuantizer_getId()
KMeansQuantizer_getId = _GRT.KMeansQuantizer_getId

class FastFourierTransform(GRTBase):
    __swig_setmethods__ = {}
    for _s in [GRTBase]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FastFourierTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [GRTBase]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FastFourierTransform, name)
    __repr__ = _swig_repr
    RECTANGULAR_WINDOW = _GRT.FastFourierTransform_RECTANGULAR_WINDOW
    BARTLETT_WINDOW = _GRT.FastFourierTransform_BARTLETT_WINDOW
    HAMMING_WINDOW = _GRT.FastFourierTransform_HAMMING_WINDOW
    HANNING_WINDOW = _GRT.FastFourierTransform_HANNING_WINDOW

    def __init__(self, *args):
        this = _GRT.new_FastFourierTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FastFourierTransform
    __del__ = lambda self: None

    def init(self, *args) -> "bool":
        return _GRT.FastFourierTransform_init(self, *args)

    def computeFFT(self, data: 'VectorFloat') -> "bool":
        return _GRT.FastFourierTransform_computeFFT(self, data)

    def getMagnitudeData(self) -> "GRT::VectorFloat":
        return _GRT.FastFourierTransform_getMagnitudeData(self)

    def getPhaseData(self) -> "GRT::VectorFloat":
        return _GRT.FastFourierTransform_getPhaseData(self)

    def getPowerData(self) -> "GRT::VectorFloat":
        return _GRT.FastFourierTransform_getPowerData(self)

    def getAveragePower(self) -> "GRT::Float":
        return _GRT.FastFourierTransform_getAveragePower(self)

    def getMagnitudeDataPtr(self) -> "GRT::Float *":
        return _GRT.FastFourierTransform_getMagnitudeDataPtr(self)

    def getPhaseDataPtr(self) -> "GRT::Float *":
        return _GRT.FastFourierTransform_getPhaseDataPtr(self)

    def getPowerDataPtr(self) -> "GRT::Float *":
        return _GRT.FastFourierTransform_getPowerDataPtr(self)

    def getFFTSize(self) -> "UINT":
        return _GRT.FastFourierTransform_getFFTSize(self)
FastFourierTransform_swigregister = _GRT.FastFourierTransform_swigregister
FastFourierTransform_swigregister(FastFourierTransform)

class FFT(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FFT, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FFT, name)
    __repr__ = _swig_repr
    RECTANGULAR_WINDOW = _GRT.FFT_RECTANGULAR_WINDOW
    BARTLETT_WINDOW = _GRT.FFT_BARTLETT_WINDOW
    HAMMING_WINDOW = _GRT.FFT_HAMMING_WINDOW
    HANNING_WINDOW = _GRT.FFT_HANNING_WINDOW

    def __init__(self, *args):
        this = _GRT.new_FFT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FFT
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.FFT_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, *args) -> "bool":
        return _GRT.FFT_computeFeatures(self, *args)

    def clear(self) -> "bool":
        return _GRT.FFT_clear(self)

    def reset(self) -> "bool":
        return _GRT.FFT_reset(self)

    def init(self, *args) -> "bool":
        return _GRT.FFT_init(self, *args)

    def update(self, *args) -> "bool":
        return _GRT.FFT_update(self, *args)

    def getHopSize(self) -> "UINT":
        return _GRT.FFT_getHopSize(self)

    def getDataBufferSize(self) -> "UINT":
        return _GRT.FFT_getDataBufferSize(self)

    def getFFTWindowSize(self) -> "UINT":
        return _GRT.FFT_getFFTWindowSize(self)

    def getFFTWindowFunction(self) -> "UINT":
        return _GRT.FFT_getFFTWindowFunction(self)

    def getHopCounter(self) -> "UINT":
        return _GRT.FFT_getHopCounter(self)

    def getComputeMagnitude(self) -> "bool":
        return _GRT.FFT_getComputeMagnitude(self)

    def getComputePhase(self) -> "bool":
        return _GRT.FFT_getComputePhase(self)

    def getFFTResults(self) -> "GRT::Vector< GRT::FastFourierTransform >":
        return _GRT.FFT_getFFTResults(self)

    def getFFTResultsPtr(self, *args) -> "GRT::Vector< GRT::FastFourierTransform > const &":
        return _GRT.FFT_getFFTResultsPtr(self, *args)

    def getFrequencyBins(self, sampleRate: 'unsigned int const') -> "GRT::VectorFloat":
        return _GRT.FFT_getFrequencyBins(self, sampleRate)

    def setHopSize(self, hopSize: 'UINT const') -> "bool":
        return _GRT.FFT_setHopSize(self, hopSize)

    def setFFTWindowSize(self, fftWindowSize: 'UINT const') -> "bool":
        return _GRT.FFT_setFFTWindowSize(self, fftWindowSize)

    def setFFTWindowFunction(self, fftWindowFunction: 'UINT const') -> "bool":
        return _GRT.FFT_setFFTWindowFunction(self, fftWindowFunction)

    def setComputeMagnitude(self, computeMagnitude: 'bool const') -> "bool":
        return _GRT.FFT_setComputeMagnitude(self, computeMagnitude)

    def setComputePhase(self, computePhase: 'bool const') -> "bool":
        return _GRT.FFT_setComputePhase(self, computePhase)

    def save(self, *args) -> "bool":
        return _GRT.FFT_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.FFT_load(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.FFT_getId)
    else:
        getId = _GRT.FFT_getId
FFT_swigregister = _GRT.FFT_swigregister
FFT_swigregister(FFT)

def FFT_getId() -> "std::string":
    return _GRT.FFT_getId()
FFT_getId = _GRT.FFT_getId

class STDVectorOfFastFourierTransform(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, STDVectorOfFastFourierTransform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, STDVectorOfFastFourierTransform, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _GRT.STDVectorOfFastFourierTransform_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _GRT.STDVectorOfFastFourierTransform___nonzero__(self)

    def __bool__(self) -> "bool":
        return _GRT.STDVectorOfFastFourierTransform___bool__(self)

    def __len__(self) -> "std::vector< GRT::FastFourierTransform >::size_type":
        return _GRT.STDVectorOfFastFourierTransform___len__(self)

    def __getslice__(self, i: 'std::vector< GRT::FastFourierTransform >::difference_type', j: 'std::vector< GRT::FastFourierTransform >::difference_type') -> "std::vector< GRT::FastFourierTransform,std::allocator< GRT::FastFourierTransform > > *":
        return _GRT.STDVectorOfFastFourierTransform___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _GRT.STDVectorOfFastFourierTransform___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< GRT::FastFourierTransform >::difference_type', j: 'std::vector< GRT::FastFourierTransform >::difference_type') -> "void":
        return _GRT.STDVectorOfFastFourierTransform___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _GRT.STDVectorOfFastFourierTransform___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< GRT::FastFourierTransform >::value_type const &":
        return _GRT.STDVectorOfFastFourierTransform___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _GRT.STDVectorOfFastFourierTransform___setitem__(self, *args)

    def pop(self) -> "std::vector< GRT::FastFourierTransform >::value_type":
        return _GRT.STDVectorOfFastFourierTransform_pop(self)

    def append(self, x: 'FastFourierTransform') -> "void":
        return _GRT.STDVectorOfFastFourierTransform_append(self, x)

    def empty(self) -> "bool":
        return _GRT.STDVectorOfFastFourierTransform_empty(self)

    def size(self) -> "std::vector< GRT::FastFourierTransform >::size_type":
        return _GRT.STDVectorOfFastFourierTransform_size(self)

    def swap(self, v: 'STDVectorOfFastFourierTransform') -> "void":
        return _GRT.STDVectorOfFastFourierTransform_swap(self, v)

    def begin(self) -> "std::vector< GRT::FastFourierTransform >::iterator":
        return _GRT.STDVectorOfFastFourierTransform_begin(self)

    def end(self) -> "std::vector< GRT::FastFourierTransform >::iterator":
        return _GRT.STDVectorOfFastFourierTransform_end(self)

    def rbegin(self) -> "std::vector< GRT::FastFourierTransform >::reverse_iterator":
        return _GRT.STDVectorOfFastFourierTransform_rbegin(self)

    def rend(self) -> "std::vector< GRT::FastFourierTransform >::reverse_iterator":
        return _GRT.STDVectorOfFastFourierTransform_rend(self)

    def clear(self) -> "void":
        return _GRT.STDVectorOfFastFourierTransform_clear(self)

    def get_allocator(self) -> "std::vector< GRT::FastFourierTransform >::allocator_type":
        return _GRT.STDVectorOfFastFourierTransform_get_allocator(self)

    def pop_back(self) -> "void":
        return _GRT.STDVectorOfFastFourierTransform_pop_back(self)

    def erase(self, *args) -> "std::vector< GRT::FastFourierTransform >::iterator":
        return _GRT.STDVectorOfFastFourierTransform_erase(self, *args)

    def __init__(self, *args):
        this = _GRT.new_STDVectorOfFastFourierTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'FastFourierTransform') -> "void":
        return _GRT.STDVectorOfFastFourierTransform_push_back(self, x)

    def front(self) -> "std::vector< GRT::FastFourierTransform >::value_type const &":
        return _GRT.STDVectorOfFastFourierTransform_front(self)

    def back(self) -> "std::vector< GRT::FastFourierTransform >::value_type const &":
        return _GRT.STDVectorOfFastFourierTransform_back(self)

    def assign(self, n: 'std::vector< GRT::FastFourierTransform >::size_type', x: 'FastFourierTransform') -> "void":
        return _GRT.STDVectorOfFastFourierTransform_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _GRT.STDVectorOfFastFourierTransform_resize(self, *args)

    def insert(self, *args) -> "void":
        return _GRT.STDVectorOfFastFourierTransform_insert(self, *args)

    def reserve(self, n: 'std::vector< GRT::FastFourierTransform >::size_type') -> "void":
        return _GRT.STDVectorOfFastFourierTransform_reserve(self, n)

    def capacity(self) -> "std::vector< GRT::FastFourierTransform >::size_type":
        return _GRT.STDVectorOfFastFourierTransform_capacity(self)
    __swig_destroy__ = _GRT.delete_STDVectorOfFastFourierTransform
    __del__ = lambda self: None
STDVectorOfFastFourierTransform_swigregister = _GRT.STDVectorOfFastFourierTransform_swigregister
STDVectorOfFastFourierTransform_swigregister(STDVectorOfFastFourierTransform)

class GRTVectorOfFastFourierTransform(STDVectorOfFastFourierTransform):
    __swig_setmethods__ = {}
    for _s in [STDVectorOfFastFourierTransform]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GRTVectorOfFastFourierTransform, name, value)
    __swig_getmethods__ = {}
    for _s in [STDVectorOfFastFourierTransform]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GRTVectorOfFastFourierTransform, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_GRTVectorOfFastFourierTransform(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_GRTVectorOfFastFourierTransform
    __del__ = lambda self: None

    def resize(self, *args) -> "bool":
        return _GRT.GRTVectorOfFastFourierTransform_resize(self, *args)

    def copy(self, rhs: 'GRTVectorOfFastFourierTransform') -> "bool":
        return _GRT.GRTVectorOfFastFourierTransform_copy(self, rhs)

    def fill(self, value: 'FastFourierTransform') -> "bool":
        return _GRT.GRTVectorOfFastFourierTransform_fill(self, value)

    def setAll(self, value: 'FastFourierTransform') -> "bool":
        return _GRT.GRTVectorOfFastFourierTransform_setAll(self, value)

    def getSize(self) -> "UINT":
        return _GRT.GRTVectorOfFastFourierTransform_getSize(self)

    def getData(self, *args) -> "GRT::FastFourierTransform const *":
        return _GRT.GRTVectorOfFastFourierTransform_getData(self, *args)
GRTVectorOfFastFourierTransform_swigregister = _GRT.GRTVectorOfFastFourierTransform_swigregister
GRTVectorOfFastFourierTransform_swigregister(GRTVectorOfFastFourierTransform)

class FFTFeatures(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FFTFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FFTFeatures, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_FFTFeatures(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FFTFeatures
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.FFTFeatures_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.FFTFeatures_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.FFTFeatures_reset(self)

    def init(self, fftWindowSize: 'UINT const', numChannelsInFFTSignal: 'UINT const', computeMaxFreqFeature: 'bool const', computeMaxFreqSpectrumRatio: 'bool const', computeCentroidFeature: 'bool const', computeTopNFreqFeatures: 'bool const', N: 'UINT const') -> "bool":
        return _GRT.FFTFeatures_init(self, fftWindowSize, numChannelsInFFTSignal, computeMaxFreqFeature, computeMaxFreqSpectrumRatio, computeCentroidFeature, computeTopNFreqFeatures, N)

    def save(self, *args) -> "bool":
        return _GRT.FFTFeatures_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.FFTFeatures_load(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.FFTFeatures_getId)
    else:
        getId = _GRT.FFTFeatures_getId
FFTFeatures_swigregister = _GRT.FFTFeatures_swigregister
FFTFeatures_swigregister(FFTFeatures)

def FFTFeatures_getId() -> "std::string":
    return _GRT.FFTFeatures_getId()
FFTFeatures_getId = _GRT.FFTFeatures_getId

class EnvelopeExtractor(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnvelopeExtractor, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EnvelopeExtractor, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_EnvelopeExtractor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_EnvelopeExtractor
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.EnvelopeExtractor_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.EnvelopeExtractor_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.EnvelopeExtractor_reset(self)

    def init(self, bufferSize: 'UINT const'=100, numDimensions: 'UINT const'=1) -> "bool":
        return _GRT.EnvelopeExtractor_init(self, bufferSize, numDimensions)

    def save(self, *args) -> "bool":
        return _GRT.EnvelopeExtractor_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.EnvelopeExtractor_load(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.EnvelopeExtractor_getId)
    else:
        getId = _GRT.EnvelopeExtractor_getId
EnvelopeExtractor_swigregister = _GRT.EnvelopeExtractor_swigregister
EnvelopeExtractor_swigregister(EnvelopeExtractor)

def EnvelopeExtractor_getId() -> "std::string":
    return _GRT.EnvelopeExtractor_getId()
EnvelopeExtractor_getId = _GRT.EnvelopeExtractor_getId

class KMeansFeatures(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeansFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeansFeatures, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_KMeansFeatures(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_KMeansFeatures
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.KMeansFeatures_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.KMeansFeatures_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.KMeansFeatures_reset(self)

    def init(self, numClustersPerLayer: 'VectorTUINT') -> "bool":
        return _GRT.KMeansFeatures_init(self, numClustersPerLayer)

    def projectDataThroughLayer(self, input: 'VectorFloat', output: 'VectorFloat', layer: 'UINT const') -> "bool":
        return _GRT.KMeansFeatures_projectDataThroughLayer(self, input, output, layer)

    def getNumLayers(self) -> "UINT":
        return _GRT.KMeansFeatures_getNumLayers(self)

    def getLayerSize(self, layerIndex: 'UINT const') -> "UINT":
        return _GRT.KMeansFeatures_getLayerSize(self, layerIndex)

    def getClusters(self) -> "GRT::Vector< GRT::MatrixFloat >":
        return _GRT.KMeansFeatures_getClusters(self)

    def save(self, *args) -> "bool":
        return _GRT.KMeansFeatures_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.KMeansFeatures_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.KMeansFeatures_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.KMeansFeatures_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.KMeansFeatures_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.KMeansFeatures_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.KMeansFeatures_getId)
    else:
        getId = _GRT.KMeansFeatures_getId
KMeansFeatures_swigregister = _GRT.KMeansFeatures_swigregister
KMeansFeatures_swigregister(KMeansFeatures)

def KMeansFeatures_getId() -> "std::string":
    return _GRT.KMeansFeatures_getId()
KMeansFeatures_getId = _GRT.KMeansFeatures_getId

class MovementIndex(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovementIndex, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovementIndex, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MovementIndex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MovementIndex
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.MovementIndex_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MovementIndex_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.MovementIndex_reset(self)

    def init(self, bufferLength: 'UINT const', numDimensions: 'UINT const') -> "bool":
        return _GRT.MovementIndex_init(self, bufferLength, numDimensions)

    def update(self, *args) -> "GRT::VectorFloat":
        return _GRT.MovementIndex_update(self, *args)

    def getData(self) -> "CircularBuffer< GRT::VectorFloat >":
        return _GRT.MovementIndex_getData(self)

    def save(self, *args) -> "bool":
        return _GRT.MovementIndex_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MovementIndex_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.MovementIndex_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.MovementIndex_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.MovementIndex_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.MovementIndex_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.MovementIndex_getId)
    else:
        getId = _GRT.MovementIndex_getId
MovementIndex_swigregister = _GRT.MovementIndex_swigregister
MovementIndex_swigregister(MovementIndex)

def MovementIndex_getId() -> "std::string":
    return _GRT.MovementIndex_getId()
MovementIndex_getId = _GRT.MovementIndex_getId

class AngleMagnitude(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AngleMagnitude, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AngleMagnitude, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_AngleMagnitude()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["angle"] = _GRT.AngleMagnitude_angle_set
    __swig_getmethods__["angle"] = _GRT.AngleMagnitude_angle_get
    if _newclass:
        angle = _swig_property(_GRT.AngleMagnitude_angle_get, _GRT.AngleMagnitude_angle_set)
    __swig_setmethods__["magnitude"] = _GRT.AngleMagnitude_magnitude_set
    __swig_getmethods__["magnitude"] = _GRT.AngleMagnitude_magnitude_get
    if _newclass:
        magnitude = _swig_property(_GRT.AngleMagnitude_magnitude_get, _GRT.AngleMagnitude_magnitude_set)
    __swig_destroy__ = _GRT.delete_AngleMagnitude
    __del__ = lambda self: None
AngleMagnitude_swigregister = _GRT.AngleMagnitude_swigregister
AngleMagnitude_swigregister(AngleMagnitude)

class MovementTrajectoryFeatures(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovementTrajectoryFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovementTrajectoryFeatures, name)
    __repr__ = _swig_repr
    CENTROID_VALUE = _GRT.MovementTrajectoryFeatures_CENTROID_VALUE
    NORMALIZED_CENTROID_VALUE = _GRT.MovementTrajectoryFeatures_NORMALIZED_CENTROID_VALUE
    CENTROID_DERIVATIVE = _GRT.MovementTrajectoryFeatures_CENTROID_DERIVATIVE
    CENTROID_ANGLE_2D = _GRT.MovementTrajectoryFeatures_CENTROID_ANGLE_2D

    def __init__(self, *args):
        this = _GRT.new_MovementTrajectoryFeatures(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MovementTrajectoryFeatures
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.MovementTrajectoryFeatures_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MovementTrajectoryFeatures_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.MovementTrajectoryFeatures_reset(self)

    def init(self, trajectoryLength: 'UINT const', numCentroids: 'UINT const', featureMode: 'UINT const', numHistogramBins: 'UINT const', numDimensions: 'UINT const', useTrajStartAndEndValues: 'bool const', useWeightedMagnitudeValues: 'bool const') -> "bool":
        return _GRT.MovementTrajectoryFeatures_init(self, trajectoryLength, numCentroids, featureMode, numHistogramBins, numDimensions, useTrajStartAndEndValues, useWeightedMagnitudeValues)

    def update(self, *args) -> "GRT::VectorFloat":
        return _GRT.MovementTrajectoryFeatures_update(self, *args)

    def getTrajectoryData(self) -> "CircularBuffer< GRT::VectorFloat >":
        return _GRT.MovementTrajectoryFeatures_getTrajectoryData(self)

    def getCentroids(self) -> "GRT::MatrixDouble":
        return _GRT.MovementTrajectoryFeatures_getCentroids(self)

    def getFeatureMode(self) -> "UINT":
        return _GRT.MovementTrajectoryFeatures_getFeatureMode(self)

    def save(self, *args) -> "bool":
        return _GRT.MovementTrajectoryFeatures_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MovementTrajectoryFeatures_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.MovementTrajectoryFeatures_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.MovementTrajectoryFeatures_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.MovementTrajectoryFeatures_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.MovementTrajectoryFeatures_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.MovementTrajectoryFeatures_getId)
    else:
        getId = _GRT.MovementTrajectoryFeatures_getId
MovementTrajectoryFeatures_swigregister = _GRT.MovementTrajectoryFeatures_swigregister
MovementTrajectoryFeatures_swigregister(MovementTrajectoryFeatures)

def MovementTrajectoryFeatures_getId() -> "std::string":
    return _GRT.MovementTrajectoryFeatures_getId()
MovementTrajectoryFeatures_getId = _GRT.MovementTrajectoryFeatures_getId

class ZeroCrossingCounter(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZeroCrossingCounter, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ZeroCrossingCounter, name)
    __repr__ = _swig_repr
    NUM_ZERO_CROSSINGS_COUNTED = _GRT.ZeroCrossingCounter_NUM_ZERO_CROSSINGS_COUNTED
    ZERO_CROSSING_MAGNITUDE = _GRT.ZeroCrossingCounter_ZERO_CROSSING_MAGNITUDE
    TOTAL_NUM_ZERO_CROSSING_FEATURES = _GRT.ZeroCrossingCounter_TOTAL_NUM_ZERO_CROSSING_FEATURES
    INDEPENDANT_FEATURE_MODE = _GRT.ZeroCrossingCounter_INDEPENDANT_FEATURE_MODE
    COMBINED_FEATURE_MODE = _GRT.ZeroCrossingCounter_COMBINED_FEATURE_MODE

    def __init__(self, *args):
        this = _GRT.new_ZeroCrossingCounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ZeroCrossingCounter
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.ZeroCrossingCounter_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.ZeroCrossingCounter_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.ZeroCrossingCounter_reset(self)

    def init(self, searchWindowSize: 'UINT const', deadZoneThreshold: 'GRT::Float const', numDimensions: 'UINT const', featureMode: 'UINT const') -> "bool":
        return _GRT.ZeroCrossingCounter_init(self, searchWindowSize, deadZoneThreshold, numDimensions, featureMode)

    def update(self, *args) -> "GRT::VectorFloat":
        return _GRT.ZeroCrossingCounter_update(self, *args)

    def setSearchWindowSize(self, searchWindowSize: 'UINT const') -> "bool":
        return _GRT.ZeroCrossingCounter_setSearchWindowSize(self, searchWindowSize)

    def setFeatureMode(self, featureMode: 'UINT const') -> "bool":
        return _GRT.ZeroCrossingCounter_setFeatureMode(self, featureMode)

    def setDeadZoneThreshold(self, deadZoneThreshold: 'GRT::Float const') -> "bool":
        return _GRT.ZeroCrossingCounter_setDeadZoneThreshold(self, deadZoneThreshold)

    def getSearchWindowSize(self) -> "UINT":
        return _GRT.ZeroCrossingCounter_getSearchWindowSize(self)

    def getNumFeatures(self) -> "UINT":
        return _GRT.ZeroCrossingCounter_getNumFeatures(self)

    def getFeatureMode(self) -> "UINT":
        return _GRT.ZeroCrossingCounter_getFeatureMode(self)

    def getDeadZoneThreshold(self) -> "GRT::Float":
        return _GRT.ZeroCrossingCounter_getDeadZoneThreshold(self)

    def getDataBuffer(self) -> "CircularBuffer< GRT::VectorFloat >":
        return _GRT.ZeroCrossingCounter_getDataBuffer(self)

    def save(self, *args) -> "bool":
        return _GRT.ZeroCrossingCounter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.ZeroCrossingCounter_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.ZeroCrossingCounter_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.ZeroCrossingCounter_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.ZeroCrossingCounter_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.ZeroCrossingCounter_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.ZeroCrossingCounter_getId)
    else:
        getId = _GRT.ZeroCrossingCounter_getId
ZeroCrossingCounter_swigregister = _GRT.ZeroCrossingCounter_swigregister
ZeroCrossingCounter_swigregister(ZeroCrossingCounter)

def ZeroCrossingCounter_getId() -> "std::string":
    return _GRT.ZeroCrossingCounter_getId()
ZeroCrossingCounter_getId = _GRT.ZeroCrossingCounter_getId

class PCA(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PCA, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PCA, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_PCA(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_PCA
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.PCA_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, *args) -> "bool":
        return _GRT.PCA_computeFeatures(self, *args)

    def reset(self) -> "bool":
        return _GRT.PCA_reset(self)

    def train_(self, *args) -> "bool":
        return _GRT.PCA_train_(self, *args)

    def init(self, numDimensions: 'UINT const', numPrincipalComponents: 'UINT const') -> "bool":
        return _GRT.PCA_init(self, numDimensions, numPrincipalComponents)

    def getPCA(self) -> "PrincipalComponentAnalysis *":
        return _GRT.PCA_getPCA(self)
    if _newclass:
        getId = staticmethod(_GRT.PCA_getId)
    else:
        getId = _GRT.PCA_getId

    def save(self, *args) -> "bool":
        return _GRT.PCA_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.PCA_load(self, *args)
PCA_swigregister = _GRT.PCA_swigregister
PCA_swigregister(PCA)

def PCA_getId() -> "std::string":
    return _GRT.PCA_getId()
PCA_getId = _GRT.PCA_getId

class RBMQuantizer(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RBMQuantizer, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RBMQuantizer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_RBMQuantizer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_RBMQuantizer
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.RBMQuantizer_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.RBMQuantizer_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.RBMQuantizer_reset(self)

    def clear(self) -> "bool":
        return _GRT.RBMQuantizer_clear(self)

    def quantize(self, *args) -> "UINT":
        return _GRT.RBMQuantizer_quantize(self, *args)

    def getQuantizerTrained(self) -> "bool":
        return _GRT.RBMQuantizer_getQuantizerTrained(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.RBMQuantizer_getNumClusters(self)

    def getQuantizedValue(self) -> "UINT":
        return _GRT.RBMQuantizer_getQuantizedValue(self)

    def getQuantizationDistances(self) -> "GRT::VectorFloat":
        return _GRT.RBMQuantizer_getQuantizationDistances(self)

    def getBernoulliRBM(self) -> "BernoulliRBM":
        return _GRT.RBMQuantizer_getBernoulliRBM(self)

    def setNumClusters(self, numClusters: 'UINT const') -> "bool":
        return _GRT.RBMQuantizer_setNumClusters(self, numClusters)

    def save(self, *args) -> "bool":
        return _GRT.RBMQuantizer_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.RBMQuantizer_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.RBMQuantizer_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.RBMQuantizer_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.RBMQuantizer_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.RBMQuantizer_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.RBMQuantizer_getId)
    else:
        getId = _GRT.RBMQuantizer_getId
RBMQuantizer_swigregister = _GRT.RBMQuantizer_swigregister
RBMQuantizer_swigregister(RBMQuantizer)

def RBMQuantizer_getId() -> "std::string":
    return _GRT.RBMQuantizer_getId()
RBMQuantizer_getId = _GRT.RBMQuantizer_getId

class SOMQuantizer(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SOMQuantizer, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SOMQuantizer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_SOMQuantizer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SOMQuantizer
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.SOMQuantizer_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.SOMQuantizer_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.SOMQuantizer_reset(self)

    def clear(self) -> "bool":
        return _GRT.SOMQuantizer_clear(self)

    def quantize(self, *args) -> "UINT":
        return _GRT.SOMQuantizer_quantize(self, *args)

    def getQuantizerTrained(self) -> "bool":
        return _GRT.SOMQuantizer_getQuantizerTrained(self)

    def getNumClusters(self) -> "UINT":
        return _GRT.SOMQuantizer_getNumClusters(self)

    def getQuantizedValue(self) -> "UINT":
        return _GRT.SOMQuantizer_getQuantizedValue(self)

    def getQuantizationDistances(self) -> "GRT::VectorFloat":
        return _GRT.SOMQuantizer_getQuantizationDistances(self)

    def getSelfOrganizingMap(self) -> "GRT::SelfOrganizingMap":
        return _GRT.SOMQuantizer_getSelfOrganizingMap(self)

    def setNumClusters(self, numClusters: 'UINT const') -> "bool":
        return _GRT.SOMQuantizer_setNumClusters(self, numClusters)

    def save(self, *args) -> "bool":
        return _GRT.SOMQuantizer_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.SOMQuantizer_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.SOMQuantizer_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.SOMQuantizer_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.SOMQuantizer_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.SOMQuantizer_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.SOMQuantizer_getId)
    else:
        getId = _GRT.SOMQuantizer_getId
SOMQuantizer_swigregister = _GRT.SOMQuantizer_swigregister
SOMQuantizer_swigregister(SOMQuantizer)

def SOMQuantizer_getId() -> "std::string":
    return _GRT.SOMQuantizer_getId()
SOMQuantizer_getId = _GRT.SOMQuantizer_getId

class TimeDomainFeatures(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeDomainFeatures, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TimeDomainFeatures, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_TimeDomainFeatures(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TimeDomainFeatures
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.TimeDomainFeatures_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.TimeDomainFeatures_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.TimeDomainFeatures_reset(self)

    def init(self, bufferLength: 'UINT const', numFrames: 'UINT const', numDimensions: 'UINT const', offsetInput: 'bool const', useMean: 'bool const', useStdDev: 'bool const', useEuclideanNorm: 'bool const', useRMS: 'bool const') -> "bool":
        return _GRT.TimeDomainFeatures_init(self, bufferLength, numFrames, numDimensions, offsetInput, useMean, useStdDev, useEuclideanNorm, useRMS)

    def update(self, *args) -> "GRT::VectorFloat":
        return _GRT.TimeDomainFeatures_update(self, *args)

    def getBufferData(self) -> "CircularBuffer< GRT::VectorFloat > const &":
        return _GRT.TimeDomainFeatures_getBufferData(self)

    def save(self, *args) -> "bool":
        return _GRT.TimeDomainFeatures_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.TimeDomainFeatures_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.TimeDomainFeatures_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.TimeDomainFeatures_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.TimeDomainFeatures_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.TimeDomainFeatures_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.TimeDomainFeatures_getId)
    else:
        getId = _GRT.TimeDomainFeatures_getId
TimeDomainFeatures_swigregister = _GRT.TimeDomainFeatures_swigregister
TimeDomainFeatures_swigregister(TimeDomainFeatures)

def TimeDomainFeatures_getId() -> "std::string":
    return _GRT.TimeDomainFeatures_getId()
TimeDomainFeatures_getId = _GRT.TimeDomainFeatures_getId

class TimeseriesBuffer(FeatureExtraction):
    __swig_setmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TimeseriesBuffer, name, value)
    __swig_getmethods__ = {}
    for _s in [FeatureExtraction]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TimeseriesBuffer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_TimeseriesBuffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_TimeseriesBuffer
    __del__ = lambda self: None

    def deepCopyFrom(self, featureExtraction: 'FeatureExtraction') -> "bool":
        return _GRT.TimeseriesBuffer_deepCopyFrom(self, featureExtraction)

    def computeFeatures(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.TimeseriesBuffer_computeFeatures(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.TimeseriesBuffer_reset(self)

    def init(self, bufferSize: 'UINT const', numDimensions: 'UINT const') -> "bool":
        return _GRT.TimeseriesBuffer_init(self, bufferSize, numDimensions)

    def update(self, *args) -> "GRT::VectorFloat":
        return _GRT.TimeseriesBuffer_update(self, *args)

    def setBufferSize(self, bufferSize: 'UINT const') -> "bool":
        return _GRT.TimeseriesBuffer_setBufferSize(self, bufferSize)

    def getBufferSize(self) -> "UINT":
        return _GRT.TimeseriesBuffer_getBufferSize(self)

    def getDataBuffer(self) -> "GRT::Vector< GRT::VectorFloat >":
        return _GRT.TimeseriesBuffer_getDataBuffer(self)

    def save(self, *args) -> "bool":
        return _GRT.TimeseriesBuffer_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.TimeseriesBuffer_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.TimeseriesBuffer_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.TimeseriesBuffer_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.TimeseriesBuffer_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.TimeseriesBuffer_predict_(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.TimeseriesBuffer_getId)
    else:
        getId = _GRT.TimeseriesBuffer_getId
TimeseriesBuffer_swigregister = _GRT.TimeseriesBuffer_swigregister
TimeseriesBuffer_swigregister(TimeseriesBuffer)

def TimeseriesBuffer_getId() -> "std::string":
    return _GRT.TimeseriesBuffer_getId()
TimeseriesBuffer_getId = _GRT.TimeseriesBuffer_getId

class ClassLabelChangeFilter(PostProcessing):
    __swig_setmethods__ = {}
    for _s in [PostProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassLabelChangeFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PostProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClassLabelChangeFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClassLabelChangeFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClassLabelChangeFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, postProcessing: 'PostProcessing') -> "bool":
        return _GRT.ClassLabelChangeFilter_deepCopyFrom(self, postProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.ClassLabelChangeFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.ClassLabelChangeFilter_reset(self)

    def init(self) -> "bool":
        return _GRT.ClassLabelChangeFilter_init(self)

    def filter(self, predictedClassLabel: 'UINT const') -> "UINT":
        return _GRT.ClassLabelChangeFilter_filter(self, predictedClassLabel)

    def getFilteredClassLabel(self) -> "UINT":
        return _GRT.ClassLabelChangeFilter_getFilteredClassLabel(self)

    def getChange(self) -> "bool":
        return _GRT.ClassLabelChangeFilter_getChange(self)
    if _newclass:
        getId = staticmethod(_GRT.ClassLabelChangeFilter_getId)
    else:
        getId = _GRT.ClassLabelChangeFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.ClassLabelChangeFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.ClassLabelChangeFilter_load(self, *args)
ClassLabelChangeFilter_swigregister = _GRT.ClassLabelChangeFilter_swigregister
ClassLabelChangeFilter_swigregister(ClassLabelChangeFilter)

def ClassLabelChangeFilter_getId() -> "std::string":
    return _GRT.ClassLabelChangeFilter_getId()
ClassLabelChangeFilter_getId = _GRT.ClassLabelChangeFilter_getId

class ClassLabelFilter(PostProcessing):
    __swig_setmethods__ = {}
    for _s in [PostProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassLabelFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PostProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClassLabelFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClassLabelFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClassLabelFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, postProcessing: 'PostProcessing') -> "bool":
        return _GRT.ClassLabelFilter_deepCopyFrom(self, postProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.ClassLabelFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.ClassLabelFilter_reset(self)

    def init(self, minimumCount: 'UINT const', bufferSize: 'UINT const') -> "bool":
        return _GRT.ClassLabelFilter_init(self, minimumCount, bufferSize)

    def filter(self, predictedClassLabel: 'UINT const') -> "UINT":
        return _GRT.ClassLabelFilter_filter(self, predictedClassLabel)

    def getFilteredClassLabel(self) -> "UINT":
        return _GRT.ClassLabelFilter_getFilteredClassLabel(self)

    def setMinimumCount(self, minimumCount: 'UINT const') -> "bool":
        return _GRT.ClassLabelFilter_setMinimumCount(self, minimumCount)

    def setBufferSize(self, bufferSize: 'UINT const') -> "bool":
        return _GRT.ClassLabelFilter_setBufferSize(self, bufferSize)
    if _newclass:
        getId = staticmethod(_GRT.ClassLabelFilter_getId)
    else:
        getId = _GRT.ClassLabelFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.ClassLabelFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.ClassLabelFilter_load(self, *args)
ClassLabelFilter_swigregister = _GRT.ClassLabelFilter_swigregister
ClassLabelFilter_swigregister(ClassLabelFilter)

def ClassLabelFilter_getId() -> "std::string":
    return _GRT.ClassLabelFilter_getId()
ClassLabelFilter_getId = _GRT.ClassLabelFilter_getId

class ClassLabelAndTimer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassLabelAndTimer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ClassLabelAndTimer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_ClassLabelAndTimer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, classLabel: 'UINT', timeoutDuration: 'unsigned long') -> "bool":
        return _GRT.ClassLabelAndTimer_set(self, classLabel, timeoutDuration)

    def getClassLabel(self) -> "UINT":
        return _GRT.ClassLabelAndTimer_getClassLabel(self)

    def timerReached(self) -> "bool":
        return _GRT.ClassLabelAndTimer_timerReached(self)

    def getRemainingTime(self) -> "unsigned long":
        return _GRT.ClassLabelAndTimer_getRemainingTime(self)
    __swig_destroy__ = _GRT.delete_ClassLabelAndTimer
    __del__ = lambda self: None
ClassLabelAndTimer_swigregister = _GRT.ClassLabelAndTimer_swigregister
ClassLabelAndTimer_swigregister(ClassLabelAndTimer)

class ClassLabelTimeoutFilter(PostProcessing):
    __swig_setmethods__ = {}
    for _s in [PostProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ClassLabelTimeoutFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PostProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ClassLabelTimeoutFilter, name)
    __repr__ = _swig_repr
    ALL_CLASS_LABELS = _GRT.ClassLabelTimeoutFilter_ALL_CLASS_LABELS
    INDEPENDENT_CLASS_LABELS = _GRT.ClassLabelTimeoutFilter_INDEPENDENT_CLASS_LABELS

    def __init__(self, *args):
        this = _GRT.new_ClassLabelTimeoutFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_ClassLabelTimeoutFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, postProcessing: 'PostProcessing') -> "bool":
        return _GRT.ClassLabelTimeoutFilter_deepCopyFrom(self, postProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.ClassLabelTimeoutFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.ClassLabelTimeoutFilter_reset(self)

    def init(self, *args) -> "bool":
        return _GRT.ClassLabelTimeoutFilter_init(self, *args)

    def filter(self, predictedClassLabel: 'UINT const') -> "UINT":
        return _GRT.ClassLabelTimeoutFilter_filter(self, predictedClassLabel)

    def getFilteredClassLabel(self) -> "UINT":
        return _GRT.ClassLabelTimeoutFilter_getFilteredClassLabel(self)

    def isTimeoutActive(self) -> "bool":
        return _GRT.ClassLabelTimeoutFilter_isTimeoutActive(self)

    def setTimeoutDuration(self, timeoutDuration: 'unsigned long const') -> "bool":
        return _GRT.ClassLabelTimeoutFilter_setTimeoutDuration(self, timeoutDuration)

    def setFilterMode(self, filterMode: 'UINT const') -> "bool":
        return _GRT.ClassLabelTimeoutFilter_setFilterMode(self, filterMode)
    if _newclass:
        getId = staticmethod(_GRT.ClassLabelTimeoutFilter_getId)
    else:
        getId = _GRT.ClassLabelTimeoutFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.ClassLabelTimeoutFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.ClassLabelTimeoutFilter_load(self, *args)
ClassLabelTimeoutFilter_swigregister = _GRT.ClassLabelTimeoutFilter_swigregister
ClassLabelTimeoutFilter_swigregister(ClassLabelTimeoutFilter)

def ClassLabelTimeoutFilter_getId() -> "std::string":
    return _GRT.ClassLabelTimeoutFilter_getId()
ClassLabelTimeoutFilter_getId = _GRT.ClassLabelTimeoutFilter_getId

class DeadZone(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeadZone, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeadZone, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_DeadZone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DeadZone
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.DeadZone_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.DeadZone_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.DeadZone_reset(self)

    def init(self, lowerLimit: 'GRT::Float', upperLimit: 'GRT::Float', numDimensions: 'UINT') -> "bool":
        return _GRT.DeadZone_init(self, lowerLimit, upperLimit, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.DeadZone_filter(self, *args)

    def getLowerLimit(self) -> "GRT::Float":
        return _GRT.DeadZone_getLowerLimit(self)

    def getUpperLimit(self) -> "GRT::Float":
        return _GRT.DeadZone_getUpperLimit(self)

    def setLowerLimit(self, lowerLimit: 'GRT::Float') -> "bool":
        return _GRT.DeadZone_setLowerLimit(self, lowerLimit)

    def setUpperLimit(self, upperLimit: 'GRT::Float') -> "bool":
        return _GRT.DeadZone_setUpperLimit(self, upperLimit)
    if _newclass:
        getId = staticmethod(_GRT.DeadZone_getId)
    else:
        getId = _GRT.DeadZone_getId

    def save(self, *args) -> "bool":
        return _GRT.DeadZone_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.DeadZone_load(self, *args)
DeadZone_swigregister = _GRT.DeadZone_swigregister
DeadZone_swigregister(DeadZone)

def DeadZone_getId() -> "std::string":
    return _GRT.DeadZone_getId()
DeadZone_getId = _GRT.DeadZone_getId

class Derivative(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Derivative, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Derivative, name)
    __repr__ = _swig_repr
    FIRST_DERIVATIVE = _GRT.Derivative_FIRST_DERIVATIVE
    SECOND_DERIVATIVE = _GRT.Derivative_SECOND_DERIVATIVE

    def __init__(self, *args):
        this = _GRT.new_Derivative(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Derivative
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.Derivative_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.Derivative_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.Derivative_reset(self)

    def init(self, derivativeOrder: 'UINT const', delta: 'GRT::Float const', numDimensions: 'UINT const', filterData: 'bool const', filterSize: 'UINT const') -> "bool":
        return _GRT.Derivative_init(self, derivativeOrder, delta, numDimensions, filterData, filterSize)

    def computeDerivative(self, *args) -> "GRT::VectorFloat":
        return _GRT.Derivative_computeDerivative(self, *args)

    def setDerivativeOrder(self, derivativeOrder: 'UINT const') -> "bool":
        return _GRT.Derivative_setDerivativeOrder(self, derivativeOrder)

    def setFilterSize(self, filterSize: 'UINT const') -> "bool":
        return _GRT.Derivative_setFilterSize(self, filterSize)

    def setDelta(self, delta: 'GRT::Float const') -> "bool":
        return _GRT.Derivative_setDelta(self, delta)

    def enableFiltering(self, filterData: 'bool const') -> "bool":
        return _GRT.Derivative_enableFiltering(self, filterData)

    def getFilterSize(self) -> "UINT":
        return _GRT.Derivative_getFilterSize(self)

    def getDerivative(self, *args) -> "GRT::Float":
        return _GRT.Derivative_getDerivative(self, *args)

    def getDerivatives(self, *args) -> "GRT::VectorFloat":
        return _GRT.Derivative_getDerivatives(self, *args)
    if _newclass:
        getId = staticmethod(_GRT.Derivative_getId)
    else:
        getId = _GRT.Derivative_getId

    def save(self, *args) -> "bool":
        return _GRT.Derivative_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.Derivative_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.Derivative_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.Derivative_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.Derivative_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.Derivative_predict_(self, *args)
Derivative_swigregister = _GRT.Derivative_swigregister
Derivative_swigregister(Derivative)

def Derivative_getId() -> "std::string":
    return _GRT.Derivative_getId()
Derivative_getId = _GRT.Derivative_getId

class DoubleMovingAverageFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleMovingAverageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleMovingAverageFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_DoubleMovingAverageFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_DoubleMovingAverageFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.DoubleMovingAverageFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.DoubleMovingAverageFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.DoubleMovingAverageFilter_reset(self)

    def init(self, filterSize: 'UINT', numDimensions: 'UINT') -> "bool":
        return _GRT.DoubleMovingAverageFilter_init(self, filterSize, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.DoubleMovingAverageFilter_filter(self, *args)

    def getFilteredData(self) -> "GRT::VectorFloat":
        return _GRT.DoubleMovingAverageFilter_getFilteredData(self)
    if _newclass:
        getId = staticmethod(_GRT.DoubleMovingAverageFilter_getId)
    else:
        getId = _GRT.DoubleMovingAverageFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.DoubleMovingAverageFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.DoubleMovingAverageFilter_load(self, *args)
DoubleMovingAverageFilter_swigregister = _GRT.DoubleMovingAverageFilter_swigregister
DoubleMovingAverageFilter_swigregister(DoubleMovingAverageFilter)

def DoubleMovingAverageFilter_getId() -> "std::string":
    return _GRT.DoubleMovingAverageFilter_getId()
DoubleMovingAverageFilter_getId = _GRT.DoubleMovingAverageFilter_getId

class FIRFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FIRFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FIRFilter, name)
    __repr__ = _swig_repr
    LPF = _GRT.FIRFilter_LPF
    HPF = _GRT.FIRFilter_HPF
    BPF = _GRT.FIRFilter_BPF

    def __init__(self, *args):
        this = _GRT.new_FIRFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_FIRFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.FIRFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.FIRFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.FIRFilter_reset(self)

    def clear(self) -> "bool":
        return _GRT.FIRFilter_clear(self)

    def buildFilter(self) -> "bool":
        return _GRT.FIRFilter_buildFilter(self)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.FIRFilter_filter(self, *args)

    def getFilterType(self) -> "GRT::FIRFilter::FilterType":
        return _GRT.FIRFilter_getFilterType(self)

    def getNumTaps(self) -> "UINT":
        return _GRT.FIRFilter_getNumTaps(self)

    def getSampleRate(self) -> "GRT::Float":
        return _GRT.FIRFilter_getSampleRate(self)

    def getCutoffFrequency(self) -> "GRT::Float":
        return _GRT.FIRFilter_getCutoffFrequency(self)

    def getCutoffFrequencyLower(self) -> "GRT::Float":
        return _GRT.FIRFilter_getCutoffFrequencyLower(self)

    def getCutoffFrequencyUpper(self) -> "GRT::Float":
        return _GRT.FIRFilter_getCutoffFrequencyUpper(self)

    def getGain(self) -> "GRT::Float":
        return _GRT.FIRFilter_getGain(self)

    def getInputBuffer(self) -> "GRT::Vector< GRT::VectorFloat >":
        return _GRT.FIRFilter_getInputBuffer(self)

    def getFilterCoefficents(self) -> "GRT::VectorFloat":
        return _GRT.FIRFilter_getFilterCoefficents(self)

    def setFilterType(self, filterType: 'GRT::FIRFilter::FilterType const') -> "bool":
        return _GRT.FIRFilter_setFilterType(self, filterType)

    def setNumTaps(self, numTaps: 'UINT const') -> "bool":
        return _GRT.FIRFilter_setNumTaps(self, numTaps)

    def setSampleRate(self, sampleRate: 'GRT::Float const') -> "bool":
        return _GRT.FIRFilter_setSampleRate(self, sampleRate)

    def setCutoffFrequency(self, *args) -> "bool":
        return _GRT.FIRFilter_setCutoffFrequency(self, *args)

    def setGain(self, gain: 'GRT::Float const') -> "bool":
        return _GRT.FIRFilter_setGain(self, gain)
    if _newclass:
        getId = staticmethod(_GRT.FIRFilter_getId)
    else:
        getId = _GRT.FIRFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.FIRFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.FIRFilter_load(self, *args)
FIRFilter_swigregister = _GRT.FIRFilter_swigregister
FIRFilter_swigregister(FIRFilter)

def FIRFilter_getId() -> "std::string":
    return _GRT.FIRFilter_getId()
FIRFilter_getId = _GRT.FIRFilter_getId

class HighPassFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HighPassFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HighPassFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_HighPassFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_HighPassFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.HighPassFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.HighPassFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.HighPassFilter_reset(self)

    def init(self, filterFactor: 'GRT::Float const', gain: 'GRT::Float const', numDimensions: 'UINT const') -> "bool":
        return _GRT.HighPassFilter_init(self, filterFactor, gain, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.HighPassFilter_filter(self, *args)

    def setGain(self, gain: 'GRT::Float const') -> "bool":
        return _GRT.HighPassFilter_setGain(self, gain)

    def setFilterFactor(self, filterFactor: 'GRT::Float const') -> "bool":
        return _GRT.HighPassFilter_setFilterFactor(self, filterFactor)

    def setCutoffFrequency(self, cutoffFrequency: 'GRT::Float const', delta: 'GRT::Float const') -> "bool":
        return _GRT.HighPassFilter_setCutoffFrequency(self, cutoffFrequency, delta)

    def getFilterFactor(self) -> "GRT::Float":
        return _GRT.HighPassFilter_getFilterFactor(self)

    def getGain(self) -> "GRT::Float":
        return _GRT.HighPassFilter_getGain(self)

    def getFilteredValues(self) -> "GRT::VectorFloat":
        return _GRT.HighPassFilter_getFilteredValues(self)
    if _newclass:
        getId = staticmethod(_GRT.HighPassFilter_getId)
    else:
        getId = _GRT.HighPassFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.HighPassFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.HighPassFilter_load(self, *args)
HighPassFilter_swigregister = _GRT.HighPassFilter_swigregister
HighPassFilter_swigregister(HighPassFilter)

def HighPassFilter_getId() -> "std::string":
    return _GRT.HighPassFilter_getId()
HighPassFilter_getId = _GRT.HighPassFilter_getId

class LeakyIntegrator(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LeakyIntegrator, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LeakyIntegrator, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_LeakyIntegrator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_LeakyIntegrator
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.LeakyIntegrator_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.LeakyIntegrator_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.LeakyIntegrator_reset(self)

    def init(self, leakRate: 'GRT::Float const', numDimensions: 'UINT const') -> "bool":
        return _GRT.LeakyIntegrator_init(self, leakRate, numDimensions)

    def update(self, *args) -> "GRT::VectorFloat":
        return _GRT.LeakyIntegrator_update(self, *args)

    def setLeakRate(self, leakRate: 'GRT::Float const') -> "bool":
        return _GRT.LeakyIntegrator_setLeakRate(self, leakRate)

    def getLeakRate(self) -> "GRT::Float":
        return _GRT.LeakyIntegrator_getLeakRate(self)
    if _newclass:
        getId = staticmethod(_GRT.LeakyIntegrator_getId)
    else:
        getId = _GRT.LeakyIntegrator_getId

    def save(self, *args) -> "bool":
        return _GRT.LeakyIntegrator_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.LeakyIntegrator_load(self, *args)
LeakyIntegrator_swigregister = _GRT.LeakyIntegrator_swigregister
LeakyIntegrator_swigregister(LeakyIntegrator)

def LeakyIntegrator_getId() -> "std::string":
    return _GRT.LeakyIntegrator_getId()
LeakyIntegrator_getId = _GRT.LeakyIntegrator_getId

class LowPassFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LowPassFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LowPassFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_LowPassFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_LowPassFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.LowPassFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.LowPassFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.LowPassFilter_reset(self)

    def init(self, filterFactor: 'GRT::Float const', gain: 'GRT::Float const', numDimensions: 'UINT const') -> "bool":
        return _GRT.LowPassFilter_init(self, filterFactor, gain, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.LowPassFilter_filter(self, *args)

    def setGain(self, gain: 'GRT::Float const') -> "bool":
        return _GRT.LowPassFilter_setGain(self, gain)

    def setFilterFactor(self, filterFactor: 'GRT::Float const') -> "bool":
        return _GRT.LowPassFilter_setFilterFactor(self, filterFactor)

    def setCutoffFrequency(self, cutoffFrequency: 'GRT::Float const', delta: 'GRT::Float const') -> "bool":
        return _GRT.LowPassFilter_setCutoffFrequency(self, cutoffFrequency, delta)

    def getFilterFactor(self) -> "GRT::Float":
        return _GRT.LowPassFilter_getFilterFactor(self)

    def getGain(self) -> "GRT::Float":
        return _GRT.LowPassFilter_getGain(self)

    def getFilteredValues(self) -> "GRT::VectorFloat":
        return _GRT.LowPassFilter_getFilteredValues(self)
    if _newclass:
        getId = staticmethod(_GRT.LowPassFilter_getId)
    else:
        getId = _GRT.LowPassFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.LowPassFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.LowPassFilter_load(self, *args)
LowPassFilter_swigregister = _GRT.LowPassFilter_swigregister
LowPassFilter_swigregister(LowPassFilter)

def LowPassFilter_getId() -> "std::string":
    return _GRT.LowPassFilter_getId()
LowPassFilter_getId = _GRT.LowPassFilter_getId

class MedianFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MedianFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MedianFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MedianFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MedianFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.MedianFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MedianFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.MedianFilter_reset(self)

    def init(self, filterSize: 'UINT const', numDimensions: 'UINT const') -> "bool":
        return _GRT.MedianFilter_init(self, filterSize, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.MedianFilter_filter(self, *args)

    def getFilterSize(self) -> "UINT":
        return _GRT.MedianFilter_getFilterSize(self)

    def getFilteredData(self) -> "GRT::VectorFloat":
        return _GRT.MedianFilter_getFilteredData(self)

    def getDataBuffer(self) -> "GRT::Vector< GRT::VectorFloat >":
        return _GRT.MedianFilter_getDataBuffer(self)
    if _newclass:
        getId = staticmethod(_GRT.MedianFilter_getId)
    else:
        getId = _GRT.MedianFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.MedianFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MedianFilter_load(self, *args)
MedianFilter_swigregister = _GRT.MedianFilter_swigregister
MedianFilter_swigregister(MedianFilter)

def MedianFilter_getId() -> "std::string":
    return _GRT.MedianFilter_getId()
MedianFilter_getId = _GRT.MedianFilter_getId

class MovingAverageFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MovingAverageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MovingAverageFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MovingAverageFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MovingAverageFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.MovingAverageFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MovingAverageFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.MovingAverageFilter_reset(self)

    def init(self, filterSize: 'UINT const', numDimensions: 'UINT const') -> "bool":
        return _GRT.MovingAverageFilter_init(self, filterSize, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.MovingAverageFilter_filter(self, *args)

    def getFilterSize(self) -> "UINT":
        return _GRT.MovingAverageFilter_getFilterSize(self)

    def getFilteredData(self) -> "GRT::VectorFloat":
        return _GRT.MovingAverageFilter_getFilteredData(self)
    if _newclass:
        getId = staticmethod(_GRT.MovingAverageFilter_getId)
    else:
        getId = _GRT.MovingAverageFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.MovingAverageFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MovingAverageFilter_load(self, *args)
MovingAverageFilter_swigregister = _GRT.MovingAverageFilter_swigregister
MovingAverageFilter_swigregister(MovingAverageFilter)

def MovingAverageFilter_getId() -> "std::string":
    return _GRT.MovingAverageFilter_getId()
MovingAverageFilter_getId = _GRT.MovingAverageFilter_getId

class RMSFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RMSFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RMSFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_RMSFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_RMSFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.RMSFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.RMSFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.RMSFilter_reset(self)

    def init(self, filterSize: 'UINT', numDimensions: 'UINT') -> "bool":
        return _GRT.RMSFilter_init(self, filterSize, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.RMSFilter_filter(self, *args)

    def getFilterSize(self) -> "UINT":
        return _GRT.RMSFilter_getFilterSize(self)

    def getFilteredData(self) -> "GRT::VectorFloat":
        return _GRT.RMSFilter_getFilteredData(self)
    if _newclass:
        getId = staticmethod(_GRT.RMSFilter_getId)
    else:
        getId = _GRT.RMSFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.RMSFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.RMSFilter_load(self, *args)
RMSFilter_swigregister = _GRT.RMSFilter_swigregister
RMSFilter_swigregister(RMSFilter)

def RMSFilter_getId() -> "std::string":
    return _GRT.RMSFilter_getId()
RMSFilter_getId = _GRT.RMSFilter_getId

class SavitzkyGolayFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SavitzkyGolayFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SavitzkyGolayFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_SavitzkyGolayFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_SavitzkyGolayFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.SavitzkyGolayFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.SavitzkyGolayFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.SavitzkyGolayFilter_reset(self)

    def init(self, numLeftHandPoints: 'UINT const', numRightHandPoints: 'UINT const', derivativeOrder: 'UINT const', smoothingPolynomialOrder: 'UINT const', numDimensions: 'UINT const') -> "bool":
        return _GRT.SavitzkyGolayFilter_init(self, numLeftHandPoints, numRightHandPoints, derivativeOrder, smoothingPolynomialOrder, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.SavitzkyGolayFilter_filter(self, *args)

    def getFilteredData(self) -> "GRT::VectorFloat":
        return _GRT.SavitzkyGolayFilter_getFilteredData(self)
    if _newclass:
        getId = staticmethod(_GRT.SavitzkyGolayFilter_getId)
    else:
        getId = _GRT.SavitzkyGolayFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.SavitzkyGolayFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.SavitzkyGolayFilter_load(self, *args)
SavitzkyGolayFilter_swigregister = _GRT.SavitzkyGolayFilter_swigregister
SavitzkyGolayFilter_swigregister(SavitzkyGolayFilter)

def SavitzkyGolayFilter_getId() -> "std::string":
    return _GRT.SavitzkyGolayFilter_getId()
SavitzkyGolayFilter_getId = _GRT.SavitzkyGolayFilter_getId

class WeightedAverageFilter(PreProcessing):
    __swig_setmethods__ = {}
    for _s in [PreProcessing]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeightedAverageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProcessing]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeightedAverageFilter, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_WeightedAverageFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_WeightedAverageFilter
    __del__ = lambda self: None

    def deepCopyFrom(self, preProcessing: 'PreProcessing') -> "bool":
        return _GRT.WeightedAverageFilter_deepCopyFrom(self, preProcessing)

    def process(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.WeightedAverageFilter_process(self, inputVector)

    def reset(self) -> "bool":
        return _GRT.WeightedAverageFilter_reset(self)

    def init(self, filterSize: 'UINT const', numDimensions: 'UINT const') -> "bool":
        return _GRT.WeightedAverageFilter_init(self, filterSize, numDimensions)

    def filter(self, *args) -> "GRT::VectorFloat":
        return _GRT.WeightedAverageFilter_filter(self, *args)

    def getFilterSize(self) -> "UINT":
        return _GRT.WeightedAverageFilter_getFilterSize(self)

    def getFilteredData(self) -> "GRT::VectorFloat":
        return _GRT.WeightedAverageFilter_getFilteredData(self)
    if _newclass:
        getId = staticmethod(_GRT.WeightedAverageFilter_getId)
    else:
        getId = _GRT.WeightedAverageFilter_getId

    def save(self, *args) -> "bool":
        return _GRT.WeightedAverageFilter_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.WeightedAverageFilter_load(self, *args)
WeightedAverageFilter_swigregister = _GRT.WeightedAverageFilter_swigregister
WeightedAverageFilter_swigregister(WeightedAverageFilter)

def WeightedAverageFilter_getId() -> "std::string":
    return _GRT.WeightedAverageFilter_getId()
WeightedAverageFilter_getId = _GRT.WeightedAverageFilter_getId

class RegressionSample(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegressionSample, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegressionSample, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_RegressionSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_RegressionSample
    __del__ = lambda self: None
    if _newclass:
        sortByInputVectorAscending = staticmethod(_GRT.RegressionSample_sortByInputVectorAscending)
    else:
        sortByInputVectorAscending = _GRT.RegressionSample_sortByInputVectorAscending
    if _newclass:
        sortByInputVectorDescending = staticmethod(_GRT.RegressionSample_sortByInputVectorDescending)
    else:
        sortByInputVectorDescending = _GRT.RegressionSample_sortByInputVectorDescending

    def clear(self) -> "void":
        return _GRT.RegressionSample_clear(self)

    def set(self, inputVector: 'VectorFloat', targetVector: 'VectorFloat') -> "void":
        return _GRT.RegressionSample_set(self, inputVector, targetVector)

    def getNumInputDimensions(self) -> "UINT":
        return _GRT.RegressionSample_getNumInputDimensions(self)

    def getNumTargetDimensions(self) -> "UINT":
        return _GRT.RegressionSample_getNumTargetDimensions(self)

    def getInputVectorValue(self, index: 'UINT const') -> "GRT::Float":
        return _GRT.RegressionSample_getInputVectorValue(self, index)

    def getTargetVectorValue(self, index: 'UINT const') -> "GRT::Float":
        return _GRT.RegressionSample_getTargetVectorValue(self, index)

    def getInputVector(self) -> "GRT::VectorFloat const &":
        return _GRT.RegressionSample_getInputVector(self)

    def getTargetVector(self) -> "GRT::VectorFloat const &":
        return _GRT.RegressionSample_getTargetVector(self)
RegressionSample_swigregister = _GRT.RegressionSample_swigregister
RegressionSample_swigregister(RegressionSample)

def RegressionSample_sortByInputVectorAscending(a: 'RegressionSample', b: 'RegressionSample') -> "bool":
    return _GRT.RegressionSample_sortByInputVectorAscending(a, b)
RegressionSample_sortByInputVectorAscending = _GRT.RegressionSample_sortByInputVectorAscending

def RegressionSample_sortByInputVectorDescending(a: 'RegressionSample', b: 'RegressionSample') -> "bool":
    return _GRT.RegressionSample_sortByInputVectorDescending(a, b)
RegressionSample_sortByInputVectorDescending = _GRT.RegressionSample_sortByInputVectorDescending

class RegressionData(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegressionData, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RegressionData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_RegressionData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_RegressionData
    __del__ = lambda self: None

    def clear(self) -> "void":
        return _GRT.RegressionData_clear(self)

    def setInputAndTargetDimensions(self, numInputDimensions: 'UINT const', numTargetDimensions: 'UINT const') -> "bool":
        return _GRT.RegressionData_setInputAndTargetDimensions(self, numInputDimensions, numTargetDimensions)

    def setDatasetName(self, datasetName: 'std::string const &') -> "bool":
        return _GRT.RegressionData_setDatasetName(self, datasetName)

    def setInfoText(self, infoText: 'std::string const &') -> "bool":
        return _GRT.RegressionData_setInfoText(self, infoText)

    def addSample(self, inputVector: 'VectorFloat', targetVector: 'VectorFloat') -> "bool":
        return _GRT.RegressionData_addSample(self, inputVector, targetVector)

    def removeLastSample(self) -> "bool":
        return _GRT.RegressionData_removeLastSample(self)

    def reserve(self, N: 'UINT const') -> "bool":
        return _GRT.RegressionData_reserve(self, N)

    def setExternalRanges(self, externalInputRanges: 'GRT::Vector< MinMax > const &', externalTargetRanges: 'GRT::Vector< MinMax > const &', useExternalRanges: 'bool const') -> "bool":
        return _GRT.RegressionData_setExternalRanges(self, externalInputRanges, externalTargetRanges, useExternalRanges)

    def enableExternalRangeScaling(self, useExternalRanges: 'bool const') -> "bool":
        return _GRT.RegressionData_enableExternalRangeScaling(self, useExternalRanges)

    def scale(self, *args) -> "bool":
        return _GRT.RegressionData_scale(self, *args)

    def save(self, filename: 'std::string const &') -> "bool":
        return _GRT.RegressionData_save(self, filename)

    def load(self, filename: 'std::string const &') -> "bool":
        return _GRT.RegressionData_load(self, filename)

    def saveDatasetToFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.RegressionData_saveDatasetToFile(self, filename)

    def loadDatasetFromFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.RegressionData_loadDatasetFromFile(self, filename)

    def saveDatasetToCSVFile(self, filename: 'std::string const &') -> "bool":
        return _GRT.RegressionData_saveDatasetToCSVFile(self, filename)

    def loadDatasetFromCSVFile(self, filename: 'std::string const &', numInputDimensions: 'UINT const', numTargetDimensions: 'UINT const') -> "bool":
        return _GRT.RegressionData_loadDatasetFromCSVFile(self, filename, numInputDimensions, numTargetDimensions)

    def printStats(self) -> "bool":
        return _GRT.RegressionData_printStats(self)

    def merge(self, regressionData: 'RegressionData') -> "bool":
        return _GRT.RegressionData_merge(self, regressionData)

    def partition(self, trainingSizePercentage: 'UINT const') -> "GRT::RegressionData":
        return _GRT.RegressionData_partition(self, trainingSizePercentage)

    def split(self, trainingSizePercentage: 'UINT const') -> "GRT::RegressionData":
        return _GRT.RegressionData_split(self, trainingSizePercentage)

    def spiltDataIntoKFolds(self, K: 'UINT const') -> "bool":
        return _GRT.RegressionData_spiltDataIntoKFolds(self, K)

    def getTrainingFoldData(self, foldIndex: 'UINT const') -> "GRT::RegressionData":
        return _GRT.RegressionData_getTrainingFoldData(self, foldIndex)

    def getTestFoldData(self, foldIndex: 'UINT const') -> "GRT::RegressionData":
        return _GRT.RegressionData_getTestFoldData(self, foldIndex)

    def removeDuplicateSamples(self) -> "UINT":
        return _GRT.RegressionData_removeDuplicateSamples(self)

    def getDatasetName(self) -> "std::string":
        return _GRT.RegressionData_getDatasetName(self)

    def getInfoText(self) -> "std::string":
        return _GRT.RegressionData_getInfoText(self)

    def getStatsAsString(self) -> "std::string":
        return _GRT.RegressionData_getStatsAsString(self)

    def getNumInputDimensions(self) -> "UINT":
        return _GRT.RegressionData_getNumInputDimensions(self)

    def getNumTargetDimensions(self) -> "UINT":
        return _GRT.RegressionData_getNumTargetDimensions(self)

    def getNumSamples(self) -> "UINT":
        return _GRT.RegressionData_getNumSamples(self)

    def getInputRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.RegressionData_getInputRanges(self)

    def getTargetRanges(self) -> "GRT::Vector< MinMax >":
        return _GRT.RegressionData_getTargetRanges(self)

    def getData(self) -> "GRT::Vector< GRT::RegressionSample >":
        return _GRT.RegressionData_getData(self)

    def get(self, i: 'int const &') -> "GRT::RegressionSample &":
        return _GRT.RegressionData_get(self, i)
RegressionData_swigregister = _GRT.RegressionData_swigregister
RegressionData_swigregister(RegressionData)

class Neuron(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Neuron, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Neuron, name)
    __repr__ = _swig_repr
    LINEAR = _GRT.Neuron_LINEAR
    SIGMOID = _GRT.Neuron_SIGMOID
    BIPOLAR_SIGMOID = _GRT.Neuron_BIPOLAR_SIGMOID
    TANH = _GRT.Neuron_TANH
    NUMBER_OF_ACTIVATION_FUNCTIONS = _GRT.Neuron_NUMBER_OF_ACTIVATION_FUNCTIONS

    def __init__(self, *args):
        this = _GRT.new_Neuron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_Neuron
    __del__ = lambda self: None

    def init(self, numInputs: 'UINT const', actvationFunction: 'GRT::Neuron::Type const', random: 'Random &', minWeightRange: 'GRT::Float const'=-0.1, maxWeightRange: 'GRT::Float const'=0.1, minBiasRange: 'GRT::Float const'=-0.1, maxBiasRange: 'GRT::Float const'=0.1) -> "bool":
        return _GRT.Neuron_init(self, numInputs, actvationFunction, random, minWeightRange, maxWeightRange, minBiasRange, maxBiasRange)

    def clear(self) -> "void":
        return _GRT.Neuron_clear(self)

    def fire(self, x: 'VectorFloat') -> "GRT::Float":
        return _GRT.Neuron_fire(self, x)

    def getDerivative(self, y: 'GRT::Float const &') -> "GRT::Float":
        return _GRT.Neuron_getDerivative(self, y)
    if _newclass:
        validateActivationFunction = staticmethod(_GRT.Neuron_validateActivationFunction)
    else:
        validateActivationFunction = _GRT.Neuron_validateActivationFunction
    __swig_setmethods__["gamma"] = _GRT.Neuron_gamma_set
    __swig_getmethods__["gamma"] = _GRT.Neuron_gamma_get
    if _newclass:
        gamma = _swig_property(_GRT.Neuron_gamma_get, _GRT.Neuron_gamma_set)
    __swig_setmethods__["bias"] = _GRT.Neuron_bias_set
    __swig_getmethods__["bias"] = _GRT.Neuron_bias_get
    if _newclass:
        bias = _swig_property(_GRT.Neuron_bias_get, _GRT.Neuron_bias_set)
    __swig_setmethods__["previousBiasUpdate"] = _GRT.Neuron_previousBiasUpdate_set
    __swig_getmethods__["previousBiasUpdate"] = _GRT.Neuron_previousBiasUpdate_get
    if _newclass:
        previousBiasUpdate = _swig_property(_GRT.Neuron_previousBiasUpdate_get, _GRT.Neuron_previousBiasUpdate_set)
    __swig_setmethods__["weights"] = _GRT.Neuron_weights_set
    __swig_getmethods__["weights"] = _GRT.Neuron_weights_get
    if _newclass:
        weights = _swig_property(_GRT.Neuron_weights_get, _GRT.Neuron_weights_set)
    __swig_setmethods__["previousUpdate"] = _GRT.Neuron_previousUpdate_set
    __swig_getmethods__["previousUpdate"] = _GRT.Neuron_previousUpdate_get
    if _newclass:
        previousUpdate = _swig_property(_GRT.Neuron_previousUpdate_get, _GRT.Neuron_previousUpdate_set)
    __swig_setmethods__["numInputs"] = _GRT.Neuron_numInputs_set
    __swig_getmethods__["numInputs"] = _GRT.Neuron_numInputs_get
    if _newclass:
        numInputs = _swig_property(_GRT.Neuron_numInputs_get, _GRT.Neuron_numInputs_set)
    __swig_setmethods__["activationFunction"] = _GRT.Neuron_activationFunction_set
    __swig_getmethods__["activationFunction"] = _GRT.Neuron_activationFunction_get
    if _newclass:
        activationFunction = _swig_property(_GRT.Neuron_activationFunction_get, _GRT.Neuron_activationFunction_set)
Neuron_swigregister = _GRT.Neuron_swigregister
Neuron_swigregister(Neuron)

def Neuron_validateActivationFunction(activationFunction: 'GRT::Neuron::Type const') -> "bool":
    return _GRT.Neuron_validateActivationFunction(activationFunction)
Neuron_validateActivationFunction = _GRT.Neuron_validateActivationFunction

class MLP(Regressifier):
    __swig_setmethods__ = {}
    for _s in [Regressifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLP, name, value)
    __swig_getmethods__ = {}
    for _s in [Regressifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLP, name)
    __repr__ = _swig_repr
    ONLINE_GRADIENT_DESCENT = _GRT.MLP_ONLINE_GRADIENT_DESCENT

    def __init__(self, *args):
        this = _GRT.new_MLP(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MLP
    __del__ = lambda self: None

    def deepCopyFrom(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.MLP_deepCopyFrom(self, regressifier)

    def clear(self) -> "bool":
        return _GRT.MLP_clear(self)

    def _print(self) -> "bool":
        return _GRT.MLP__print(self)

    def getNumClasses(self) -> "UINT":
        return _GRT.MLP_getNumClasses(self)

    def init(self, *args) -> "bool":
        return _GRT.MLP_init(self, *args)

    def printNetwork(self) -> "void":
        return _GRT.MLP_printNetwork(self)

    def checkForNAN(self) -> "bool":
        return _GRT.MLP_checkForNAN(self)

    def activationFunctionToString(self, activationFunction: 'GRT::Neuron::Type const') -> "std::string":
        return _GRT.MLP_activationFunctionToString(self, activationFunction)

    def activationFunctionFromString(self, activationName: 'std::string const') -> "GRT::Neuron::Type":
        return _GRT.MLP_activationFunctionFromString(self, activationName)

    def validateActivationFunction(self, avactivationFunction: 'GRT::Neuron::Type const') -> "bool":
        return _GRT.MLP_validateActivationFunction(self, avactivationFunction)

    def getNumInputNeurons(self) -> "UINT":
        return _GRT.MLP_getNumInputNeurons(self)

    def getNumHiddenNeurons(self) -> "UINT":
        return _GRT.MLP_getNumHiddenNeurons(self)

    def getNumOutputNeurons(self) -> "UINT":
        return _GRT.MLP_getNumOutputNeurons(self)

    def getNumRandomTrainingIterations(self) -> "UINT":
        return _GRT.MLP_getNumRandomTrainingIterations(self)

    def getInputLayerActivationFunction(self) -> "GRT::Neuron::Type":
        return _GRT.MLP_getInputLayerActivationFunction(self)

    def getHiddenLayerActivationFunction(self) -> "GRT::Neuron::Type":
        return _GRT.MLP_getHiddenLayerActivationFunction(self)

    def getOutputLayerActivationFunction(self) -> "GRT::Neuron::Type":
        return _GRT.MLP_getOutputLayerActivationFunction(self)

    def getTrainingRate(self) -> "GRT::Float":
        return _GRT.MLP_getTrainingRate(self)

    def getMomentum(self) -> "GRT::Float":
        return _GRT.MLP_getMomentum(self)

    def getGamma(self) -> "GRT::Float":
        return _GRT.MLP_getGamma(self)

    def getTrainingError(self) -> "GRT::Float":
        return _GRT.MLP_getTrainingError(self)

    def getClassificationModeActive(self) -> "bool":
        return _GRT.MLP_getClassificationModeActive(self)

    def getRegressionModeActive(self) -> "bool":
        return _GRT.MLP_getRegressionModeActive(self)

    def getInputLayer(self) -> "GRT::Vector< GRT::Neuron >":
        return _GRT.MLP_getInputLayer(self)

    def getHiddenLayer(self) -> "GRT::Vector< GRT::Neuron >":
        return _GRT.MLP_getHiddenLayer(self)

    def getOutputLayer(self) -> "GRT::Vector< GRT::Neuron >":
        return _GRT.MLP_getOutputLayer(self)

    def getTrainingLog(self) -> "GRT::Vector< GRT::VectorFloat >":
        return _GRT.MLP_getTrainingLog(self)

    def getNullRejectionEnabled(self) -> "bool":
        return _GRT.MLP_getNullRejectionEnabled(self)

    def getNullRejectionCoeff(self) -> "GRT::Float":
        return _GRT.MLP_getNullRejectionCoeff(self)

    def getNullRejectionThreshold(self) -> "GRT::Float":
        return _GRT.MLP_getNullRejectionThreshold(self)

    def getMaximumLikelihood(self) -> "GRT::Float":
        return _GRT.MLP_getMaximumLikelihood(self)

    def getClassLikelihoods(self) -> "GRT::VectorFloat":
        return _GRT.MLP_getClassLikelihoods(self)

    def getClassDistances(self) -> "GRT::VectorFloat":
        return _GRT.MLP_getClassDistances(self)

    def getPredictedClassLabel(self) -> "UINT":
        return _GRT.MLP_getPredictedClassLabel(self)

    def setInputLayerActivationFunction(self, activationFunction: 'GRT::Neuron::Type const') -> "bool":
        return _GRT.MLP_setInputLayerActivationFunction(self, activationFunction)

    def setHiddenLayerActivationFunction(self, activationFunction: 'GRT::Neuron::Type const') -> "bool":
        return _GRT.MLP_setHiddenLayerActivationFunction(self, activationFunction)

    def setOutputLayerActivationFunction(self, activationFunction: 'GRT::Neuron::Type const') -> "bool":
        return _GRT.MLP_setOutputLayerActivationFunction(self, activationFunction)

    def setTrainingRate(self, trainingRate: 'GRT::Float const') -> "bool":
        return _GRT.MLP_setTrainingRate(self, trainingRate)

    def setMomentum(self, momentum: 'GRT::Float const') -> "bool":
        return _GRT.MLP_setMomentum(self, momentum)

    def setGamma(self, gamma: 'GRT::Float const') -> "bool":
        return _GRT.MLP_setGamma(self, gamma)

    def setNumRandomTrainingIterations(self, numRandomTrainingIterations: 'UINT const') -> "bool":
        return _GRT.MLP_setNumRandomTrainingIterations(self, numRandomTrainingIterations)

    def setNullRejection(self, useNullRejection: 'bool const') -> "bool":
        return _GRT.MLP_setNullRejection(self, useNullRejection)

    def setNullRejectionCoeff(self, nullRejectionCoeff: 'GRT::Float const') -> "bool":
        return _GRT.MLP_setNullRejectionCoeff(self, nullRejectionCoeff)
    if _newclass:
        getId = staticmethod(_GRT.MLP_getId)
    else:
        getId = _GRT.MLP_getId

    def save(self, *args) -> "bool":
        return _GRT.MLP_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MLP_load(self, *args)

    def train(self, *args) -> "bool":
        return _GRT.MLP_train(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.MLP_train_(self, *args)

    def predict(self, *args) -> "bool":
        return _GRT.MLP_predict(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.MLP_predict_(self, *args)
MLP_swigregister = _GRT.MLP_swigregister
MLP_swigregister(MLP)

def MLP_getId() -> "std::string":
    return _GRT.MLP_getId()
MLP_getId = _GRT.MLP_getId

class LinearRegression(Regressifier):
    __swig_setmethods__ = {}
    for _s in [Regressifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearRegression, name, value)
    __swig_getmethods__ = {}
    for _s in [Regressifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearRegression, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_LinearRegression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_LinearRegression
    __del__ = lambda self: None

    def deepCopyFrom(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.LinearRegression_deepCopyFrom(self, regressifier)

    def train_(self, trainingData: 'RegressionData') -> "bool":
        return _GRT.LinearRegression_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.LinearRegression_predict_(self, inputVector)

    def getMaxNumIterations(self) -> "UINT":
        return _GRT.LinearRegression_getMaxNumIterations(self)

    def setMaxNumIterations(self, maxNumIterations: 'UINT const') -> "bool":
        return _GRT.LinearRegression_setMaxNumIterations(self, maxNumIterations)
    if _newclass:
        getId = staticmethod(_GRT.LinearRegression_getId)
    else:
        getId = _GRT.LinearRegression_getId

    def save(self, *args) -> "bool":
        return _GRT.LinearRegression_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.LinearRegression_load(self, *args)
LinearRegression_swigregister = _GRT.LinearRegression_swigregister
LinearRegression_swigregister(LinearRegression)

def LinearRegression_getId() -> "std::string":
    return _GRT.LinearRegression_getId()
LinearRegression_getId = _GRT.LinearRegression_getId

class LogisticRegression(Regressifier):
    __swig_setmethods__ = {}
    for _s in [Regressifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogisticRegression, name, value)
    __swig_getmethods__ = {}
    for _s in [Regressifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LogisticRegression, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_LogisticRegression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_LogisticRegression
    __del__ = lambda self: None

    def deepCopyFrom(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.LogisticRegression_deepCopyFrom(self, regressifier)

    def train_(self, trainingData: 'RegressionData') -> "bool":
        return _GRT.LogisticRegression_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.LogisticRegression_predict_(self, inputVector)

    def getMaxNumIterations(self) -> "UINT":
        return _GRT.LogisticRegression_getMaxNumIterations(self)

    def setMaxNumIterations(self, maxNumIterations: 'UINT') -> "bool":
        return _GRT.LogisticRegression_setMaxNumIterations(self, maxNumIterations)
    if _newclass:
        getId = staticmethod(_GRT.LogisticRegression_getId)
    else:
        getId = _GRT.LogisticRegression_getId

    def save(self, *args) -> "bool":
        return _GRT.LogisticRegression_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.LogisticRegression_load(self, *args)
LogisticRegression_swigregister = _GRT.LogisticRegression_swigregister
LogisticRegression_swigregister(LogisticRegression)

def LogisticRegression_getId() -> "std::string":
    return _GRT.LogisticRegression_getId()
LogisticRegression_getId = _GRT.LogisticRegression_getId

class MultidimensionalRegression(Regressifier):
    __swig_setmethods__ = {}
    for _s in [Regressifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultidimensionalRegression, name, value)
    __swig_getmethods__ = {}
    for _s in [Regressifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultidimensionalRegression, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_MultidimensionalRegression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_MultidimensionalRegression
    __del__ = lambda self: None

    def deepCopyFrom(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.MultidimensionalRegression_deepCopyFrom(self, regressifier)

    def train_(self, trainingData: 'RegressionData') -> "bool":
        return _GRT.MultidimensionalRegression_train_(self, trainingData)

    def predict_(self, inputVector: 'VectorFloat') -> "bool":
        return _GRT.MultidimensionalRegression_predict_(self, inputVector)

    def getIsRegressionModuleSet(self) -> "bool":
        return _GRT.MultidimensionalRegression_getIsRegressionModuleSet(self)

    def getRegressifier(self) -> "GRT::Regressifier *":
        return _GRT.MultidimensionalRegression_getRegressifier(self)

    def setRegressionModule(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.MultidimensionalRegression_setRegressionModule(self, regressifier)
    if _newclass:
        getId = staticmethod(_GRT.MultidimensionalRegression_getId)
    else:
        getId = _GRT.MultidimensionalRegression_getId

    def save(self, *args) -> "bool":
        return _GRT.MultidimensionalRegression_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.MultidimensionalRegression_load(self, *args)
MultidimensionalRegression_swigregister = _GRT.MultidimensionalRegression_swigregister
MultidimensionalRegression_swigregister(MultidimensionalRegression)

def MultidimensionalRegression_getId() -> "std::string":
    return _GRT.MultidimensionalRegression_getId()
MultidimensionalRegression_getId = _GRT.MultidimensionalRegression_getId

class RegressionTreeNode(Node):
    __swig_setmethods__ = {}
    for _s in [Node]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegressionTreeNode, name, value)
    __swig_getmethods__ = {}
    for _s in [Node]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RegressionTreeNode, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _GRT.new_RegressionTreeNode()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_RegressionTreeNode
    __del__ = lambda self: None

    def predict_(self, *args) -> "bool":
        return _GRT.RegressionTreeNode_predict_(self, *args)

    def clear(self) -> "bool":
        return _GRT.RegressionTreeNode_clear(self)

    def _print(self) -> "bool":
        return _GRT.RegressionTreeNode__print(self)

    def deepCopy(self) -> "GRT::Node *":
        return _GRT.RegressionTreeNode_deepCopy(self)

    def deepCopyTree(self) -> "GRT::RegressionTreeNode *":
        return _GRT.RegressionTreeNode_deepCopyTree(self)

    def set(self, nodeSize: 'UINT const', featureIndex: 'UINT const', threshold: 'GRT::Float const', regressionData: 'VectorFloat') -> "bool":
        return _GRT.RegressionTreeNode_set(self, nodeSize, featureIndex, threshold, regressionData)
RegressionTreeNode_swigregister = _GRT.RegressionTreeNode_swigregister
RegressionTreeNode_swigregister(RegressionTreeNode)

class RegressionTree(Regressifier):
    __swig_setmethods__ = {}
    for _s in [Regressifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegressionTree, name, value)
    __swig_getmethods__ = {}
    for _s in [Regressifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RegressionTree, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _GRT.new_RegressionTree(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GRT.delete_RegressionTree
    __del__ = lambda self: None

    def deepCopyFrom(self, regressifier: 'Regressifier') -> "bool":
        return _GRT.RegressionTree_deepCopyFrom(self, regressifier)

    def clear(self) -> "bool":
        return _GRT.RegressionTree_clear(self)

    def _print(self) -> "bool":
        return _GRT.RegressionTree__print(self)

    def deepCopyTree(self) -> "GRT::RegressionTreeNode *":
        return _GRT.RegressionTree_deepCopyTree(self)

    def getTree(self) -> "GRT::RegressionTreeNode const *":
        return _GRT.RegressionTree_getTree(self)

    def getMinRMSErrorPerNode(self) -> "GRT::Float":
        return _GRT.RegressionTree_getMinRMSErrorPerNode(self)

    def getTrainingMode(self) -> "GRT::Tree::TrainingMode":
        return _GRT.RegressionTree_getTrainingMode(self)

    def getNumSplittingSteps(self) -> "UINT":
        return _GRT.RegressionTree_getNumSplittingSteps(self)

    def getMinNumSamplesPerNode(self) -> "UINT":
        return _GRT.RegressionTree_getMinNumSamplesPerNode(self)

    def getMaxDepth(self) -> "UINT":
        return _GRT.RegressionTree_getMaxDepth(self)

    def getPredictedNodeID(self) -> "UINT":
        return _GRT.RegressionTree_getPredictedNodeID(self)

    def getRemoveFeaturesAtEachSpilt(self) -> "bool":
        return _GRT.RegressionTree_getRemoveFeaturesAtEachSpilt(self)

    def setTrainingMode(self, trainingMode: 'GRT::Tree::TrainingMode const') -> "bool":
        return _GRT.RegressionTree_setTrainingMode(self, trainingMode)

    def setNumSplittingSteps(self, numSplittingSteps: 'UINT const') -> "bool":
        return _GRT.RegressionTree_setNumSplittingSteps(self, numSplittingSteps)

    def setMinNumSamplesPerNode(self, minNumSamplesPerNode: 'UINT const') -> "bool":
        return _GRT.RegressionTree_setMinNumSamplesPerNode(self, minNumSamplesPerNode)

    def setMaxDepth(self, maxDepth: 'UINT const') -> "bool":
        return _GRT.RegressionTree_setMaxDepth(self, maxDepth)

    def setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt: 'bool const') -> "bool":
        return _GRT.RegressionTree_setRemoveFeaturesAtEachSpilt(self, removeFeaturesAtEachSpilt)

    def setMinRMSErrorPerNode(self, minRMSErrorPerNode: 'GRT::Float const') -> "bool":
        return _GRT.RegressionTree_setMinRMSErrorPerNode(self, minRMSErrorPerNode)
    if _newclass:
        getId = staticmethod(_GRT.RegressionTree_getId)
    else:
        getId = _GRT.RegressionTree_getId

    def save(self, *args) -> "bool":
        return _GRT.RegressionTree_save(self, *args)

    def load(self, *args) -> "bool":
        return _GRT.RegressionTree_load(self, *args)

    def train_(self, *args) -> "bool":
        return _GRT.RegressionTree_train_(self, *args)

    def predict_(self, *args) -> "bool":
        return _GRT.RegressionTree_predict_(self, *args)
RegressionTree_swigregister = _GRT.RegressionTree_swigregister
RegressionTree_swigregister(RegressionTree)

def RegressionTree_getId() -> "std::string":
    return _GRT.RegressionTree_getId()
RegressionTree_getId = _GRT.RegressionTree_getId

# This file is compatible with both classic and new-style classes.


